[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tutorial: Modflow 6 + Flopy",
    "section": "",
    "text": "Introducción\nCuadernos interactivos para MODFLOW 6 + Flopy",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "00_MF6_Intro.html",
    "href": "00_MF6_Intro.html",
    "title": "1  MODFLOW 6: introducción.",
    "section": "",
    "text": "1.1 Resumen.\nEl propósito de este documento es describir la arquitectura de MODFLOW 6, sus componentes y paquetes, así como los elementos principales que se usan en una simulación de flujo con el modelo GWF. Esta descripción se basa en la documentación de MODFLOW 6 y solo se explican los conceptos principales para entender la forma en que interactúan todas las componentes y paquetes durante una simulación.\nMODFLOW 6: introducción by Luis M. de la Cruz Salas (2025) is licensed under Attribution-ShareAlike 4.0 International.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>MODFLOW 6: introducción.</span>"
    ]
  },
  {
    "objectID": "00_MF6_Intro.html#la-simulación.",
    "href": "00_MF6_Intro.html#la-simulación.",
    "title": "1  MODFLOW 6: introducción.",
    "section": "4.1 La simulación.",
    "text": "4.1 La simulación.\nUna simulación consiste de una ejecución que puede incluir varios modelos (de flujo, de transporte, de intercambios, numéricos, etcétera). La simulación es la componente de mayor nivel y está controlada por el programa principal. La siguiente figura, tomada de [1], esquematiza el flujo de una simulación.\n\nEl programa principal ejecuta varios procedimientos, conocidos como primary procedures en la secuencia apropiada para realizar y controlar la simulación.\n\nCR: Crea objetos de tipo model, package, exchange y/o solution.\nDF: Define algunos atributos de los objetos, por ejemplo el tamaño de algunos arreglos.\nAR: Genera los arreglos. También lee información que será constante durante toda la simulación.\nTU: Incrementa las variables del tiempo y calcula la longitudes del paso de tiempo.\nRP: Lee la información de los archivos de entrada, conforme se necesite, para actualizar los estreses hidrológicos u otras entradas que varían con el tiempo.\nCA: Actualiza las variables dependientes. Para soluciones numéricas, utiliza métodos iterativos para resolver sistemas de ecuaciones no lineales.\nOT: Escribe los resultados de la simulación en archivos para cada paso de tiempo o como sea requerido.\nFP: Escribe mensajes de terminación y cierra todos los archivos.\nDA: Desaloja toda la memoria.\n\nComo puede observarse TU, RP, CA y OT se ejecutan varias veces dentro del ciclo temporal. Cada paso en el diagrama representa ejecuciones para todos los models, exchanges y solutions que forman parte de la simulación.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>MODFLOW 6: introducción.</span>"
    ]
  },
  {
    "objectID": "00_MF6_Intro.html#la-discretización-temporal.",
    "href": "00_MF6_Intro.html#la-discretización-temporal.",
    "title": "1  MODFLOW 6: introducción.",
    "section": "4.2 La discretización temporal.",
    "text": "4.2 La discretización temporal.\nUna simulación se divide en intervalos de tiempo, conocidos como periodos de estrés, durante los cuales los datos de entrada de todos los estreses externos permanecen constantes. Los periodos de estrés se dividen a su vez en pasos de tiempo, como se muestra en la siguiente figura (véase Timing Module en [1], pp 10-12):\n\nEsta componente implementa y ejecuta las operaciones del procedimiento primario Time Update (TU).\nLa tabla siguiente describe algunos de los parámetros que se usan en este módulo:\n\n\n\n\n\n\n\n\nVariable\nTipo\nSignificado\n\n\n\n\nPERLEN\ndouble\nes la longitud del periodo de estrés\n\n\nNSTP\ninteger\nes el número de pasos de tiempo en un periodo de estrés\n\n\nTSMULT\ndouble\nes el multiplicador para calcular la longitud de pasos de tiempo sucesivos\n\n\n\nPara calcular la longitud del primer paso de tiempo en un periodo de estrés se hace lo siguiente:\n\nPara TSMULT \\(= 1\\):\n\n\\[\n\\Delta t_1= \\frac{\\text{PERLEN}}{\\text{NSTP}}\n\\]\n\nPara TSMULT \\(\\neq 1\\):\n\n\\[\n\\Delta t_1= \\text{PERLEN} \\frac{\\text{TSMULT} - 1}{\\text{TSMULT}^\\text{nstp}-1}\n\\]\nLa longitud de cada paso de tiempo sucesivo es calculada multiplicando la longitud del paso de tiempo previo por TSMULT.\n\\[\n\\Delta t = \\Delta t_{old} \\text{TSMULT}\n\\]\n\n4.2.1 Ejemplo 1. Periodo de estrés.\nConsidérese un modelo de flujo GWF que usa los paquetes de River y Well, en donde el tiempo de simulación es de \\(90\\) días, con pasos de tiempo de un día.\n\nSi el nivel del río o el bombeo de los pozos solo cambian cada \\(30\\) días, se pueden usar \\(3\\) períodos de estrés, cada uno de \\(30\\) días.\nDe igual manera, si el bombeo o el nivel del río varían cada \\(3\\) días, se usarían \\(30\\) períodos de estrés de \\(3\\) días.\nCuando comienza un nuevo período de estrés, se deben redefinir todos los datos de estrés; sin embargo, la mayoría de los paquetes podrían reutilizar los datos del período de estrés anterior.\nEn este ejemplo, se podrían reutilizar los datos del río en un nuevo período de estrés cuando solo cambian las tasas de bombeo mientras que el nivel del río permanece igual.\n\nNOTA. Los períodos de estrés se implementan solo por conveniencia. Los paquetes que definen estreses dependientes del tiempo leen los datos de entrada en cada período de estrés. Los períodos de estrés facilitan la gestión de datos de entrada que se mantienen constantes por múltiples intervalos de tiempo. Sin embargo, no son inusuales las situaciones en las que surge la necesidad de cambiar los datos de estrés en cada paso de tiempo. En este caso, cada período de estrés debería constar de un solo paso de tiempo; como alternativa, se puede utilizar la funcionalidad de series temporales (Time Series) que está integrada en MODFLOW 6, véase Utilities - Time Series en [1], pp 27-28.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>MODFLOW 6: introducción.</span>"
    ]
  },
  {
    "objectID": "00_MF6_Intro.html#la-solución-numérica.",
    "href": "00_MF6_Intro.html#la-solución-numérica.",
    "title": "1  MODFLOW 6: introducción.",
    "section": "4.3 La solución numérica.",
    "text": "4.3 La solución numérica.\nLa componente Numerical Solution es una parte clave del simulador, ya que se encarga de configurar el solucionador que se usará para resolver las ecuaciones de uno o más modelos y de los intercambios que los conectan.\nEn términos simples en esta componente se definen:\n\nel tipo de solucionador numérico que se usará (ej. Newton-Raphson, métodos iterativos lineales (CG o BiCGSTAB),\nlos criterios de convergencia (número máximo de iteraciones, tolerancias, etc.),\nla asociación entre modelos y la solución numérica (por ejemplo, un modelo de flujo puede estar vinculado con una o varias soluciones numéricas en caso de que haya múltiples modelos o dominios acoplados).\n\nEl modelo numérico de GWF formula un sistema lineal de ecuaciones de la forma:\n\\[\n\\mathbf{A} \\mathbf{x} = \\mathbf{b}\n\\]\ndonde \\(\\mathbf{A}\\) es la matriz de coeficientes, \\(\\mathbf{x}\\) es el vector de variables dependientes (la carga hidráulica, por ejemplo) y \\(\\mathbf{b}\\) es el lado derecho del sistema con valores conocidos (ej. las condiciones iniciales y de frontera).\n\n\nEn la figura de la izquierda, tomada de [1], se muestra un ejemplo ilustrativo de una matriz para tres modelos numéricos, con sus respectivos intercambios que los conectan entre sí, que se resuelve por un solo componente de tipo Numerical Solution.\nLa componente Numerical Solution resuelve el sistema de ecuaciones para uno o más modelos usando métodos iterativos.\nEstos métodos son capaces de manejar matrices dispersas, simétricas y no simétricas, de tal manera que es posible resolver problemas en mallas no estructuradas, formulaciones tipo Newton-Raphson, flujo de agua anisotrópico, transporte de solutos dispersivo, entre otros.\n\nJerarquía de clases de los solucionadores numéricos.\n\n\nBaseSolutionType es la clase base general para cualquier tipo de solución en MODFLOW 6; de esta superclase deben heredar todas las clases para calcular las soluciones numéricas.\nNumericalSolutionType Es una especialización de BaseSolutionType, que está orientada exclusivamente a métodos numéricos iterativos. Está diseñada para resolver uno o más modelos numéricos.\nIterativeModelSolutionType (IMS) es una implementación concreta de la clase NumericalSolutionType y se encarga de resolver uno o varios modelos acoplados. En una simulación se crean objetos de esta clase para calcular la solución numérica.\n\n\n\nLos procedimientos primarios de la clase BaseSolutionType se muestran en la figura de la derecha (tomada de [1]).\nObservése que el programa principal ejecuta procedimientos específicos de BaseSolutionType.\nObsérvese también que en este caso no se ejecuta el procedimiento TU, pues esta es tarea del TimingModule.\nEn el procedimiento CA es donde se implementan los métodos iterativos para resolver el sistema de ecuaciones generado por los modelos e intercambios que se agreguen a la simulación.\nCuando el sistema es no lineal, se resuelve una forma linealizada del sistema de manera iterativa usando métodos iterativos y precondicionados.\nEl solucionador descrito en [3] ha sido extendido en MODFLOW 6 para incluir los aceleradores lineales CG, BiCGSTAB e ILU.\nLa naturaleza no lineal de los sistemas de ecuaciones, se gestiona con los métodos backtracking, pseudo-transient continuation, under-relaxation methods y Newton Dampening.\n\nLas siguientes figuras muestran diagramas de flujo de los métodos lineales y no lineales implementados en el procedimiento CA.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>MODFLOW 6: introducción.</span>"
    ]
  },
  {
    "objectID": "00_MF6_Intro.html#los-modelos.",
    "href": "00_MF6_Intro.html#los-modelos.",
    "title": "1  MODFLOW 6: introducción.",
    "section": "4.4 Los modelos.",
    "text": "4.4 Los modelos.\nJerarquía de clases de los modelos.\n\n\nTodos los modelos deben ser subclases de la clase principal BaseModelType.\nUn modelo numérico está definido por la clase NumericalModelType y es un tipo especial de un modelo diseñado para colaborar con la clase NumericalSolutionType.\nEl modelo GWF está definido en la clase GwfModelType que es una subclase de la clase NumericalModelType.\n\nEn MODFLOW 6 un modelo es una componente principal de la simulación y representa un proceso hidrológico (flujo subterráneo, flujo laminar o turbulento en conductos, flujo superficial, transporte de calor o de soluto, entre otros).\n\n\nLos procedimientos que se ejecutan de BaseModelType , desde el programa principal, son los que se muestran en la figura de la izquierda (tomada de [1]).\nEstos métodos o procedimientos, generalmente están vacíos (son abstractos en términos de la POO) y pueden ser implementados por métodos que están definidos en las subclases de BaseModelType (sobrecarga).\nObsérvese que en este caso no se ejecutan los procedimientos TU ni CA, pues ellos están definidos en otras componentes de la simulación.\nEsta construcción hace más fácil la adaptación y modificación de nuevos modelos.\n\n\n4.4.1 Modelos numéricos.\nEn la figura se muestran los procedimientos primarios que se ejecutan de las clases NumericalModelType y NumericalSolutionType.\n\n\nCR: Crea el modelo numérico y los paquetes requeridos.\nDF: Define el modelo numérico leyendo la información del tamaño del modelo.\nAC: Adiciona las conexiones del modelo a Numerical Solution reservando espacios dentro de la matriz de coeficientes.\nMC: Crea un arreglo de índices que mapea las conexiones del modelo dentro del sistema de ecuaciones.\nAR: Asigna memoria para los arreglos del modelo y lee información que será constante durante toda la simulación.\nRP: Lee información del modelo de archivos, conforme es requerida, para actualizar los estreses hidrológicos u otras entradas que varían con el tiempo.\nAD: Avanza el modelo al siguiente paso en el tiempo, típicamente almacenando el valor anterior de las variables dependientes.\nCF: Calcula y actualiza los coeficientes que dependen de los resultados de la última iteración.\nFC: Calcula y agrega los términos del modelo a la matriz de coeficientes y al RHS de Numerical Solution.\nNR: Calcula y agrega los términos del método de Newton-Raphson del modelo a la matriz de coeficientes y al RHS de Numerical Solution.\nCC: Realiza una revisión de la convergencia en las variables dependientes que no son parte del modelo numérico.\nND: Ajusta los valores de las variables dependientes, lo que puede mejorar la convergencia para modelos que usan la formulación de Newton-Raphson.\nBD: Calcula el balance con base en la solución actualizada para la variable dependiente.\nOT: Escribe los resultados de la simulación en archivos para cada paso de tiempo o como sea requerido.\nFP: Escribe mensajes de terminación y cierra todos los archivos.\nDA: Desaloja toda la memoria.\n\n\n\n4.4.2 Groundwater Flow Model (GWF)\nEl modelo GWF es un tipo específico de un modelo numérico y está definido en la clase GwfModelType la cual está diseñada para colaborar con la clase IterativeModelSolutionType. La figura muestra un diagrama de flujo donde se muestran los procedimientos primarios que son ejecutados de ambas clases, veáse [4].\n\n\nCR: crea un objeto del modelo GWF con el nombre especificado y es almacenado en una lista de modelos. También crea objetos de todos los paquetes asociados a la simulación, además asigna valores a algunos parámetros del modelo.\nDF: abre archivos, lee la información acerca del tamaño del modelo, la conectividad de las celdas de la malla y crea los objetos de los paquetes que definen las condiciones de frontera.\nAC: informa al solucionador IMS sobre el número total de celdas del modelo GWF y cómo están conectadas entre ellas; esta información es usada por IMS para configurar el tamaño y patrón de conectividad de la matriz del sistema de ecuaciones.\nMC: este procedimiento se ejecuta después de que el patrón de conectividad ha sido determinado para IMS. Se crea un arreglo que mapea la posición de las celdas del modelo GWF con sus conecciones dentro del sistema de ecuaciones. Esta información es usada por GWF que son parte de los procedimientos que agregan términos al sistema de ecuaciones.\nAR: se determinan algunos parámetros hidrológicas y se reserva memoria para los componentes de la simulación que no fueron definidas por el procedimiento DF. También se leen los datos que se mantienen constantes de un periodo de estrés a otro. Estos datos incluyen: parte de la información de las fronteras, cargas hidráulicas iniciales y propiedades hidráulicas del acuífero. Se realizan algunos cálculos preliminares para preparar los datos para un procesamiento posterior.\nRP: se ejecuta al inicio de cada paso de tiempo, pero solamente lee y procesa bloques de información si es el primer paso de tiempo del periodo de estress. Esta información incluye razones de bombeo y áreas de recarga, por ejemplo.\nAD: inicializa la carga, realiza realiza sustitución de series de tiempo y ejecuta los procedimientos de los paquetes de fronteras individuales. También realiza otros procesamientos que deben ser efectuados al principio de cada paso de tiempo.\nCF: calcula términos que serán requeridos en otros procedimientos. También rehumedece las celdas, si es necesario, y vuelve inactivas las celdas secas.\nFC: adiciona los coeficients a la matriz \\(A\\) y al vector de lado derecho \\(b\\).\nNR: adiciona los términos de Newton-Raphson a la matriz \\(A\\) y al vector de lado derecho \\(b\\). Solo se invoca cuando el método de Newton-Raphson es usado por el modelo GWF.\nCC: se realiza una verificación de la convergencia de variables que no son parte de la solución numérica, particularmente sobre paquetes avanzados que trabajan sobre la frontera.\nND: se ejecuta el procedimiento Newton Dampening para amortiguar cambios de cargar grandes e irreales. Específicamente, si la carga simulada de una celda está por debajo del límite inferior del modelo, esta se ajusta hacia arriba, hacia el límite inferior del modelo.\nBD: calcula los términos del balance de flujo para el modelo GWF y los paquetes de frontera.\nFP: escribe la salida final del modelo y realiza algunas tareas de procesamiento final.\nDA: Desaloja toda la memoria utilizada por el modelo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>MODFLOW 6: introducción.</span>"
    ]
  },
  {
    "objectID": "01_MF6_GWF_init.html",
    "href": "01_MF6_GWF_init.html",
    "title": "2  MODFLOW 6: inicializando una simulación.",
    "section": "",
    "text": "2.1 Resumen.\nEl propósito de este documento es describir cómo se realiza una simulación de flujo usando el modelo GWF de MODFLOW 6. Esta descripción combina los conceptos descritos en la documentación de MODFLOW 6 y en el software flopy (repositorio, documentación). El software flopy permite simplificar la generación de los archivos de entrada para una simulación a través de Python, además de realizar la ejecución de la simulación y el post-procesamiento de la salida. No se hace una descripción detallada, sino que solo se explican los conceptos principales y se relacionan con los archivos de entrada requeridos por MODFLOW 6 y con los objetos de flopy. Se hace una configuración de una simulación agregando las componentes Timing module, Numerical Solution (IMS) y un GWF model, usando parámetros reducidos.\nMODFLOW 6: inicializando una simulación by Luis M. de la Cruz Salas (2025) is licensed under Attribution-ShareAlike 4.0 International.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>MODFLOW 6: inicializando una simulación.</span>"
    ]
  },
  {
    "objectID": "01_MF6_GWF_init.html#ejemplo.-las-tres-componentes-de-una-simulación-con-flopy.",
    "href": "01_MF6_GWF_init.html#ejemplo.-las-tres-componentes-de-una-simulación-con-flopy.",
    "title": "2  MODFLOW 6: inicializando una simulación.",
    "section": "2.2 Ejemplo. Las tres componentes de una simulación con flopy.",
    "text": "2.2 Ejemplo. Las tres componentes de una simulación con flopy.\nUna simulación simple con GWF requiere de las componentes que se muestran en la siguiente figura:\n\n\n\nFigura 1. Diagrama que muestra las componentes que se usan para la simulación de un solo modelo GWF. Las componentes son: (1) una simulación (que es el programa principal), (2) una componente para gestionar el tiempo, (3) una componente para gestionar la solución numérica y (4) un único modelo GWF. Figura tomada de [1].\n\n\nPara definir las tres componentes mostradas en la figura anterior hacemos uso de la biblioteca flopy. Realizaremos este proceso para un ejemplo simple, cuya única utilidad es explicar el proceso (sin resolver un problema de flujo).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>MODFLOW 6: inicializando una simulación.</span>"
    ]
  },
  {
    "objectID": "02_MF6_GWF_paq.html",
    "href": "02_MF6_GWF_paq.html",
    "title": "3  MODFLOW 6: modelo GWF.",
    "section": "",
    "text": "3.1 Resumen.\nEn este documento se realiza una simulación de flujo en dos dimensiones explicando paso a paso el proceso y describiendo los paquetes del modelo GWF que son usados. Se utilizan las herramientas de flopy para facilitar el pre y postprocesamiento de la información requerida por el simulador.\nMODFLOW 6: modelo GWF by Luis M. de la Cruz Salas (2025) is licensed under Attribution-ShareAlike 4.0 International.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>MODFLOW 6: modelo GWF.</span>"
    ]
  },
  {
    "objectID": "02_MF6_GWF_paq.html#paso-1.-configuración-inicial.",
    "href": "02_MF6_GWF_paq.html#paso-1.-configuración-inicial.",
    "title": "3  MODFLOW 6: modelo GWF.",
    "section": "5.1 Paso 1. Configuración inicial.",
    "text": "5.1 Paso 1. Configuración inicial.\n\nHaremos la configuración inicial de la simulación de manera similar al ejemplo de la notebook 01_MF6_GWF_init.ipynb.\nEn este caso agregaremos algunas opciones adicionales al solucionador IMS para ver el efecto que tiene en los archivos de entrada, particularmente en flow.ims, véase Iterative Model Solution, pp 225-231, en [2].\nEl espacio de trabajo donde se escriben todos los archivos será la carpeta sandbox2.\nLa simulación así como el modelo de flujo tendrán el nombre flow.\nTodo lo anterior se realiza en la siguiente celda de código:\n\n\nimport flopy\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\n\n# Biblioteca con algunas herramientas adicionales que se puede instalar como sigue:\n#pip install git+https://github.com/luiggix/xmf6\nimport xmf6 \n\n# --- Ruta a los ejecutables de MODFLOW 6. Opciones de SO's: linux, macos, macosarm, windows\nexe_name = \"C:\\\\Users\\\\luiggi\\\\Documents\\\\GitSites\\\\xmf6\\\\mf6\\\\windows\\\\mf6\"\n#exe_name = \"../../../mf6/macosarm/mf6\"\n\n# --- Configuración inicial ---\nsim_name = \"flow\"\nsim_ws = \"sandbox2\"\n\no_sim = flopy.mf6.MFSimulation(\n    sim_name = sim_name,\n    exe_name = exe_name,\n    sim_ws   = sim_ws\n)\n\n# --- Tiempos de simulación ---\no_tdis = flopy.mf6.ModflowTdis(\n    simulation = o_sim,\n    time_units = \"DAYS\",\n    nper = 1,\n    perioddata = [(1.0, 1, 1.0)],\n)\n\n# --- Solucionador numérico (IMS) ---\no_ims = flopy.mf6.ModflowIms(\n    simulation          = o_sim,\n    print_option        = \"SUMMARY\",\n    complexity          = \"SIMPLE\",\n    outer_dvclose       = 1e-4,\n    outer_maximum       = 50,\n    under_relaxation    = \"NONE\",\n    linear_acceleration = \"CG\",\n    inner_maximum       = 30,\n    inner_dvclose       = 1e-6,\n)\n\n# --- Modelo GWF ---\no_gwf = flopy.mf6.ModflowGwf(\n    simulation = o_sim,\n    modelname = sim_name,\n    model_nam_file = f\"{sim_name}.nam\",\n    save_flows = True # Almacena los flujos, particularmente el budget\n)\n\n# --- Escribimos los archivos ---\no_sim.write_simulation()\n\nwriting simulation...\n  writing simulation name file...\n  writing simulation tdis package...\n  writing solution package ims_-1...\n  writing model flow...\n    writing model name file...\n\n\n\nObservación.\nRevisa los archivos generados en la carpeta sandbox2, particularmente el archivo flow.ims.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>MODFLOW 6: modelo GWF.</span>"
    ]
  },
  {
    "objectID": "02_MF6_GWF_paq.html#paquetes.",
    "href": "02_MF6_GWF_paq.html#paquetes.",
    "title": "3  MODFLOW 6: modelo GWF.",
    "section": "5.2 Paquetes.",
    "text": "5.2 Paquetes.\nPara generar esta simulación se requiere de agregar paquetes al modelo GWF como se muestra en la siguiente figura, tomada de [1]:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>MODFLOW 6: modelo GWF.</span>"
    ]
  },
  {
    "objectID": "02_MF6_GWF_paq.html#paso-2.-discretización-espacial.",
    "href": "02_MF6_GWF_paq.html#paso-2.-discretización-espacial.",
    "title": "3  MODFLOW 6: modelo GWF.",
    "section": "5.3 Paso 2. Discretización espacial.",
    "text": "5.3 Paso 2. Discretización espacial.\nEl dominio espacial de una simulación en MODFLOW 6 se divide en una rejilla de celdas y provee de tres paquetes diferentes (véase Chapter 3. Spatial Discretization en [1]):\n\nDIS. Paquete para discretización estructurada.\nDISV. Paquete para discretización por vértices.\nDISU. Paquete para discretización NO estructurada.\n\nSolo se puede usar uno de los paquetes de discretización en una simulación con GWF.\nLa información almacenada en los paquetes de discretización es usada durante la simulación por GWF para realizar varias acciones, por ejemplo: * calcular la conductividad hidráulica entre celdas conectadas, * calcular los volúmenes de celda para los cálculos de almacenamiento, * convertir los flujos de recarga y evapotranspiración, por ejemplo de las dimensiones de L/T a L\\(^3\\)/T.\nLos paquetes de discretización: * contienen información acerca de las celdas, como las elevaciones superior (TOP) e inferior (BOTTOM) de la celda y las dimensiones o áreas de la celda (en vista de planta). * definen la conectividad de las celdas para describir cómo están conectadas entre sí las celdas del modelo y las propiedades geométricas de las conexiones. * En el paquete DIS, la conectividad de la celda se describe implícitamente por la estructura de la malla, las dimensiones de la celda en las direcciones de renglones y columnas, y las elevaciones de la parte superior e inferior de la celda.\nLa siguiente figura, tomada de [1], muestra un ejemplo de una malla regular en tres dimensiones en donde se definen columnas, renglones y capas.\n\n\nEn este ejemplo tenemos 9 columnas (NROW), 5 renglones (NCOL) y 5 capas (NLAY).\nEl tamaño horizontal de las celdas está definido por \\(\\Delta r_i\\) y \\(\\Delta c_i\\) (variables DELR\\(_i\\) y DELC\\(_i\\)).\nObserva que \\(\\Delta r_i\\) se mide en la dirección de los renglones (en el eje \\(x\\) en un sistema Cartesiano), es decir, mide el tamaño de la columna \\(i\\)-ésima.\nPor otro lado, \\(\\Delta c_i\\) se mide en la dirección de las columnas (en el eje \\(y\\)), por lo que mide el tamaño del renglón \\(i\\)-ésimo\nLas capas se numeran empezando por la capa superior y hacia abajo.\nLas elevaciones de las celdas se especifican en la variable BOTM (indica la parte inferior de cada capa).\nLa elevación de la parte superior de la primera capa se debe especificar en la variable TOP.\nLa información de las elevaciones se usa para calcular el espesor de las celdas.\n\n\nParámetros a usar.\n\nPara obtener el modelo del dominio rectangular requerido, una capa de \\(15\\) m \\(\\times\\) \\(10\\) m con un espesor de \\(1\\) m, usaremos los parámetros nrow, ncol, nlay, delr y delc.\nPara obtener la longitud correcta del dominio se debe cumplir que:\n\nnrow * delc $ = 15$,\nncol * delr $ = 10$.\n\nLos parámetros top y botm deben ser tales que top - botm \\(= 1\\).\nEn la siguiente celda se definen estos parámetros para generar la malla del dominio:\n\n\n\n# --- Discretización espacial ---\nnlay = 1\nnrow = 10\nncol = 15\ndelr = 1.0\ndelc = 1.0\ntop  = 0.0\nbotm = -1.0\n\no_dis = flopy.mf6.ModflowGwfdis(\n    model = o_gwf,\n    length_units = \"METERS\",\n    nlay = nlay,\n    nrow = nrow,\n    ncol = ncol,\n    delr = delr,\n    delc = delc,\n    top  = top,\n    botm = botm,\n)\n\nprint(o_dis)\no_sim.write_simulation()\n\npackage_name = dis\nfilename = flow.dis\npackage_type = dis\nmodel_or_simulation_package = model\nmodel_name = flow\n\nBlock options\n--------------------\nlength_units\n{internal}\n(meters)\n\n\nBlock dimensions\n--------------------\nnlay\n{internal}\n(1)\n\nnrow\n{internal}\n(10)\n\nncol\n{internal}\n(15)\n\n\nBlock griddata\n--------------------\ndelr\n{constant 1.0}\n\ndelc\n{constant 1.0}\n\ntop\n{constant 0.0}\n\nbotm\n{constant -1.0}\n\n\n\nwriting simulation...\n  writing simulation name file...\n  writing simulation tdis package...\n  writing solution package ims_-1...\n  writing model flow...\n    writing model name file...\n    writing package dis...\n\n\n\nExplicación.\n\nEn la celda anterior se construye el objeto o_dis de la clase flopy.mf6.ModflowGwfdis para generar la información de la discretización espacial. Esta clase construye una discretiación de tipo DIS.\nEl primer parámetro en esta construcción es el objeto del modelo al que esta discretización pertenece, en este caso o_gwf. Posteriormente se agregan todos los parámetros de la discretización.\nLa celda anterior genera el archivo flow.dis con la información correspondiente a la discretización espacial, revisa este archivo en la carpeta sandbox2.\nAdicionalmente, el archivo flow.nam es modificado agregando la información del paquete DIS, deberías ver un bloque como el siguiente en ese archivo:\n\nBEGIN packages\n  DIS6  flow.dis  dis\nEND packages\n\nFlopy contiene herramientas para obtener la información de la discretización espacial y hacer una gráfica del dominio. Por ejemplo:\n\no_gwf.modelgrid: regresa un objeto que contiene toda la información de la discretización.\no_gwf.modelgrid.extent: extensión del dominio (xmin, xmax, ymin, ymax).\no_gwf.modelgrid.nrow: número de renglones.\no_gwf.modelgrid.ncol: número de columnas.\no_gwf.modelgrid.nlay: número de capas.\no_gwf.modelgrid.delr: tamaño de las celdas en dirección de los renglones (coord. \\(x\\), tamaño de las columas).\no_gwf.modelgrid.delc: tamaño de las celdas en dirección de las columnas (coord. \\(y\\), tamaño de los renglones).\no_gwf.modelgrid.delz: tamaño de las celdas en dirección vertical (coord. \\(z\\), tamaño de las capas).\no_gwf.modelgrid.top: parte superior de la primera capa.\no_gwf.modelgrid.botm: parte inferior de todas las celdas.\no_gwf.modelgrid.xyzcellcenters: centros de las celdas de la malla\n\nVeamos como podemos obtener y usar esta información.\n\n# Obtenemos el objeto con la información de la discretización espacial\ngrid = o_gwf.modelgrid\n\ngrid.extent\nprint(\"Extensión del dominio (xmin, xmax, ymin, ymax)\")\nprint(grid.extent[0], grid.extent[1], grid.extent[2], grid.extent[3])\n\nprint(\"\\nNúmero de renglones, columnas y capas\")\nprint(grid.nrow, grid.ncol, grid.nlay)\n\nExtensión del dominio (xmin, xmax, ymin, ymax)\n0.0 15.0 0.0 10.0\n\nNúmero de renglones, columnas y capas\n10 15 1\n\n\n\nprint(len(grid.delr), grid.delr)\n# grid.delr es un numpy.ndarray 1D de tamaño ncol\n# grid.delc es un numpy.ndarray 1D de tamaño nrow\n# grid.delz es un numpy.ndarray 3D de tamaño nlay x ncol x nrow\n# Usamos la función xmf6.info_array() para imprimir las propiedades de arreglos de numpy\nprint(\"\\ngrid.delr =\", grid.delr[0])\nxmf6.info_array(grid.delr)\nprint(\"\\ngrid.delc =\", grid.delc[0])\nxmf6.info_array(grid.delc)\nprint(\"\\ngrid.delz =\", grid.delz[0][0][0])\nxmf6.info_array(grid.delz)\n\n15 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]\n\ngrid.delr = 1.0\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : float64 \n dim   : 1 \n shape : (15,) \n size(bytes) : 8 \n size(elements) : 15\n\ngrid.delc = 1.0\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : float64 \n dim   : 1 \n shape : (10,) \n size(bytes) : 8 \n size(elements) : 10\n\ngrid.delz = 1.0\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : float64 \n dim   : 3 \n shape : (1, 10, 15) \n size(bytes) : 8 \n size(elements) : 150\n\n\n\n# grid.top es un numpy.ndarray 2D de tamaño nrow x ncol\n# grid.botm es un numpy.ndarray 3D de tamaño nlay x nrow x ncol\nprint(\"grid.top =\", grid.top[0][0])\nxmf6.info_array(grid.top)\nprint(\"\\ngrid.botm =\", grid.botm[0][0][0])\nxmf6.info_array(grid.botm)\n\ngrid.top = 0.0\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : float64 \n dim   : 2 \n shape : (10, 15) \n size(bytes) : 8 \n size(elements) : 150\n\ngrid.botm = -1.0\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : float64 \n dim   : 3 \n shape : (1, 10, 15) \n size(bytes) : 8 \n size(elements) : 150\n\n\n\n# Dos maneras de calcular la longitud del dominio en las direcciones de los ejes son:\nprint(\"(1) Lx = \", grid.extent[1] - grid.extent[0])\nprint(\"    Ly = \", grid.extent[3] - grid.extent[2])\nprint(\"(2) Lx = \", grid.ncol * grid.delr[0])\nprint(\"    Ly = \", grid.nrow * grid.delc[0])\n\n(1) Lx =  15.0\n    Ly =  10.0\n(2) Lx =  15.0\n    Ly =  10.0\n\n\n\n# grid.xyzcellcenters es una lista que contiene un numpy.ndarray de nrow x ncol\nprint(\"grid.xyzcellcenters[0]\")\nxmf6.info_array(grid.xyzcellcenters[0])\n\ngrid.xyzcellcenters[0]\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : float64 \n dim   : 2 \n shape : (10, 15) \n size(bytes) : 8 \n size(elements) : 150\n\n\nFlopy contiene herramientas para visualización. Por ejemplo podemos crear un objeto de la clase flopy.plot.PlotMapView para graficar la malla:\n\n# Crear objeto de vista en planta\nmapview = flopy.plot.PlotMapView(model=o_gwf)\n\n# Dibujar la malla\nmapview.plot_grid(linewidths=0.75, color=\"silver\")\n\nplt.title(\"Malla del modelo GWF\")\nplt.xlabel(\"X (m)\")\nplt.ylabel(\"Y (m)\")\nplt.gca().set_aspect('equal')  # Para mantener proporciones\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>MODFLOW 6: modelo GWF.</span>"
    ]
  },
  {
    "objectID": "02_MF6_GWF_paq.html#paso-3.-condiciones-iniciales.",
    "href": "02_MF6_GWF_paq.html#paso-3.-condiciones-iniciales.",
    "title": "3  MODFLOW 6: modelo GWF.",
    "section": "5.4 Paso 3. Condiciones iniciales.",
    "text": "5.4 Paso 3. Condiciones iniciales.\nEl paquete encargado de definir las condiciones iniciales es IC (Initial Conditions). Véase Initial Conditions (IC) Package, pp 43 en [2], para más información.\nSe utiliza para asignar los valores iniciales de la carga hidráulica en todas las celdas activas del modelo al comenzar una simulación, especialmente importante cuando se trabaja con modelos transitorios.\nSe aplica al inicio del primer periodo de estrés y es obligatorio en el modelo GWF.\nEn simulaciones estacionarias, los valores iniciales no afectan los resultados finales, pero aún así son requeridos por MODFLOW 6.\nEl modelo no podrá ejecutarse correctamente si no se proporciona este paquete.\n\nParámetros a usar.\n\nUsaremos la clase flopy.mf6.ModflowGwfic para crear el objeto o_ic.\nEl primer parámetro es el modelo o_gwf al que se le desean agregar las condiciones iniciales.\nEl parámetro strt indica el valor de la condición inicial para la carga hidráulica. Puede ser un número escalar (mismo valor en todo el dominio) o un arreglo 2D o 3D para especificar la carga en cada celda.\n\nEn la siguiente celda se genera una condición inicial de carga hidráulica igual a \\(10\\):\n\n\no_ic = flopy.mf6.ModflowGwfic(\n    model = o_gwf,\n    strt=10.0 \n)\n\nprint(o_ic)\no_sim.write_simulation()\n\npackage_name = ic\nfilename = flow.ic\npackage_type = ic\nmodel_or_simulation_package = model\nmodel_name = flow\n\nBlock griddata\n--------------------\nstrt\n{constant 10.0}\n\n\n\nwriting simulation...\n  writing simulation name file...\n  writing simulation tdis package...\n  writing solution package ims_-1...\n  writing model flow...\n    writing model name file...\n    writing package dis...\n    writing package ic...\n\n\n\nExplicación.\n\nLa celda anterior genera el archivo flow.ic con la información para las condiciones iniciales.\nAdicionalmente se agrega la información de este paquete en el archivo flow.nam. Deberías obtener un bloque en ese archivo como el que sigue:\n\nBEGIN packages\n  DIS6  flow.dis  dis\n  IC6  flow.ic  ic\nEND packages\n\nTIP. Si se tiene un modelo con topografía variable y se desea usar la elevación superior como condición inicial, se podría hacer algo como:\nstrt = top.copy()  # usar la elevación como nivel inicial\nic = flopy.mf6.ModflowGwfic(gwf, strt=strt)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>MODFLOW 6: modelo GWF.</span>"
    ]
  },
  {
    "objectID": "02_MF6_GWF_paq.html#paso-4.-condiciones-de-frontera.",
    "href": "02_MF6_GWF_paq.html#paso-4.-condiciones-de-frontera.",
    "title": "3  MODFLOW 6: modelo GWF.",
    "section": "5.5 Paso 4. Condiciones de frontera.",
    "text": "5.5 Paso 4. Condiciones de frontera.\nEL paquete CHD tienen un funcionamiento diferente al de los otros paquetes hidrológicos de MODFLOW 6; no adiciona cambios en el sistema de ecuaciones como lo hacen otros paquetes. Lo que hace CHD es simplemente asignar un código interno indicando que:\n\nla carga varía con el tiempo (celda con carga variable),\nla carga es constante (celda con carga constante),\nno hay flujo hacia dentro o hacia afuera de la celda (celda inactiva).\n\nEste código es usado por la componente de solución numérica para determinar cómo debe manejar las ecuaciones.\nEl paquete CHD lee los datos del archivo con extensión .chd en donde se indica la lista de celdas con el valor correspondiente y lee la información al inicio de cada periodo de estrés, lo que hace posible cambiar el valor de la carga en dichas celdas durante la simulación.\nCon este paquete se pueden imponer condiciones de frontera de tipo Dirichlet para la carga hidráulica.\nVéase Constant-Head (CHD) Package, pp 76 en [2], para más información.\n\nPreparación de los datos.\n\nPara definir las condiciones \\(h = 10\\) en \\(x=0\\) y \\(h = 5\\) en \\(x=15\\), primero crearemos una lista de índices y valores como sigue:\n\n\n\nchd_data = []\nfor row in range(nrow):\n    chd_data.append([(0, row, 0), 10.0])       # Condición en la pared izquierda\n    chd_data.append([(0, row, ncol - 1), 5.0]) # Condición en la pared derecha\n\n# Revisamos el resultado\nfor c in chd_data:\n    print(c)\n\n[(0, 0, 0), 10.0]\n[(0, 0, 14), 5.0]\n[(0, 1, 0), 10.0]\n[(0, 1, 14), 5.0]\n[(0, 2, 0), 10.0]\n[(0, 2, 14), 5.0]\n[(0, 3, 0), 10.0]\n[(0, 3, 14), 5.0]\n[(0, 4, 0), 10.0]\n[(0, 4, 14), 5.0]\n[(0, 5, 0), 10.0]\n[(0, 5, 14), 5.0]\n[(0, 6, 0), 10.0]\n[(0, 6, 14), 5.0]\n[(0, 7, 0), 10.0]\n[(0, 7, 14), 5.0]\n[(0, 8, 0), 10.0]\n[(0, 8, 14), 5.0]\n[(0, 9, 0), 10.0]\n[(0, 9, 14), 5.0]\n\n\n\nParámetros a usar.\n\nAhora creamos un objeto de la clase flopy.mf6.ModflowGwfchd.\nEl primer parámetro será el modelo o_gwf al que se le impondrán las condiciones iniciales.\nEn este ejemplo usamos el parámetro stress_period_data para definir las condiciones de frontera, que requiere una lista de la forma: [cellid, head, aux, boundname] donde:\n\ncellid es el identificador de la celda.\n\nPara una malla de tipo DIS el CELLID está formado por tuplas (layer, row, column).\nSe usan arreglos que inician en \\(0\\).\nFlopy ajustará el valor de los índices para ejecutar MODFLOW 6 en donde los índices inician en \\(1\\).\n\nhead es el valor de la carga hidráulica en la frontera.\nlos valores aux y boundname son opcionales y no se usarán por ahora.\n\nLa lista chd_data creada anteriormente se usará como argumento de stress_period_data, veamos como:\n\n\n\no_chd = flopy.mf6.ModflowGwfchd(\n    model = o_gwf,\n    stress_period_data=chd_data,\n)\n\nprint(o_chd)\no_sim.write_simulation()\n\npackage_name = chd_0\nfilename = flow.chd\npackage_type = chd\nmodel_or_simulation_package = model\nmodel_name = flow\n\nBlock period\n--------------------\nstress_period_data\n{internal}\n(    cellid_layer  cellid_row  cellid_column  head\n0              0           0              0  10.0\n1              0           0             14   5.0\n2              0           1              0  10.0\n3              0           1             14   5.0\n4              0           2              0  10.0\n5              0           2             14   5.0\n6              0           3              0  10.0\n7              0           3             14   5.0\n8              0           4              0  10.0\n9              0           4             14   5.0\n10             0           5              0  10.0\n11             0           5             14   5.0\n12             0           6              0  10.0\n13             0           6             14   5.0\n14             0           7              0  10.0\n15             0           7             14   5.0\n16             0           8              0  10.0\n17             0           8             14   5.0\n18             0           9              0  10.0\n19             0           9             14   5.0)\n\n\n\nwriting simulation...\n  writing simulation name file...\n  writing simulation tdis package...\n  writing solution package ims_-1...\n  writing model flow...\n    writing model name file...\n    writing package dis...\n    writing package ic...\n    writing package chd_0...\nINFORMATION: maxbound in ('gwf6', 'chd', 'dimensions') changed to 20 based on size of stress_period_data\n\n\n\nObservación.\nEl resultado se escribirá en el archivo flow.chd que contendrá la lista de celdas con el valor correspondiente.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>MODFLOW 6: modelo GWF.</span>"
    ]
  },
  {
    "objectID": "02_MF6_GWF_paq.html#paso-5.-propiedades-hidráulicas.",
    "href": "02_MF6_GWF_paq.html#paso-5.-propiedades-hidráulicas.",
    "title": "3  MODFLOW 6: modelo GWF.",
    "section": "5.6 Paso 5. Propiedades hidráulicas.",
    "text": "5.6 Paso 5. Propiedades hidráulicas.\nEl paquete NPF (Node Property Flow) calcula la conductancia hidráulica, tanto vertical como horizontal, entre celdas adyancentes.\nEste paquete calcula los coeficientes \\(C_{n,m}\\) que aparecen en la siguiente forma de la ecuación CVFD:\n\\[\n\\sum_{m \\in \\eta_n} C_{n,m}(h_m - h_n) - P_n h_n + Q_n = SS_n A_n \\Delta v_n \\dfrac{h_n - HOLD_n}{t -t_{old}}\n\\]\nNPF soporta celdas confinadas y convertibles. Para determinar el tipo de celda se usa el parámetro ICELLTYPE.\nTambién, usando NPF se define la conductividad hidráulica \\(k\\).\nPara más información véase [1] Chapter 4. Internal Flow Packages, pp 4-1, y Node Property Flow (NPF) Package, pp 49 en [2].\n\nParámetros a usar.\n\nEn este caso la conductividad hidráulica es constante \\(k = 1.0\\).\nUsamos un objeto de la clase flopy.mf6.ModflowGwfnpf para definir el valor de \\(k\\).\nTambién agregamos el parámetro save_specific_discharge = True para almacenar la descarga específica \\(q\\).\n\n\n\no_npf = flopy.mf6.ModflowGwfnpf(\n    model = o_gwf,\n    save_specific_discharge = True,\n    k = 1.0, # conductividad hidráulica (constante)\n)\n\nprint(o_npf)\no_sim.write_simulation()\n\npackage_name = npf\nfilename = flow.npf\npackage_type = npf\nmodel_or_simulation_package = model\nmodel_name = flow\n\nBlock options\n--------------------\nsave_specific_discharge\n{internal}\n(True)\n\n\nBlock griddata\n--------------------\nicelltype\n{constant 0}\n\nk\n{constant 1.0}\n\n\n\nwriting simulation...\n  writing simulation name file...\n  writing simulation tdis package...\n  writing solution package ims_-1...\n  writing model flow...\n    writing model name file...\n    writing package dis...\n    writing package ic...\n    writing package chd_0...\n    writing package npf...\n\n\n\nObservación.\nEl código anterior genera el archivo flow.npf con el siguiente contenido:\n# File generated by Flopy version 3.9.2 on 04/26/2025 at 11:32:43.\nBEGIN options\n  SAVE_SPECIFIC_DISCHARGE\nEND options\n\nBEGIN griddata\n  icelltype\n    CONSTANT  0\n  k\n    CONSTANT       1.00000000\nEND griddata",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>MODFLOW 6: modelo GWF.</span>"
    ]
  },
  {
    "objectID": "02_MF6_GWF_paq.html#paso-6.-configuración-de-la-salida.",
    "href": "02_MF6_GWF_paq.html#paso-6.-configuración-de-la-salida.",
    "title": "3  MODFLOW 6: modelo GWF.",
    "section": "5.7 Paso 6. Configuración de la salida.",
    "text": "5.7 Paso 6. Configuración de la salida.\nEL paquete OC (Output Control) determina cómo y cuándo se imprimirá o almacenará la información de salida de la simulación carga hidráulica (head) y del budget.\nEsta información se puede enviar a: * la pantalla de salida cuando se ejectua MODFLOW 6, * los archivos de listado .lst, * archivos en formato binario.\nPara más información véase Output Control (OC) Option, pp 44 en [2].\n\nParámetros a usar.\n\nPara configurar la salida usamos un objeto de la clase flopy.mf6.ModflowGwfoc indicando:\n\nEl modelo GWF,\nlos archivos para almacenar el budget (flow.bud) y la carga hidráulica (flow.hds),\nla información que se almacenará en archivos binarios usando el parámetro saverecord,\nla información que se enviará al archivo de listado (flow.lst) usando el parámetro printrecord.\n\n\n\n\no_oc = flopy.mf6.ModflowGwfoc(\n    model = o_gwf,\n    budget_filerecord = f\"{sim_name}.bud\",\n    head_filerecord = f\"{sim_name}.hds\",\n    saverecord = [(\"HEAD\", \"ALL\"), (\"BUDGET\", \"ALL\")],\n    printrecord = [(\"HEAD\", \"ALL\")]\n)\n\nprint(o_oc)\no_sim.write_simulation()\n\npackage_name = oc\nfilename = flow.oc\npackage_type = oc\nmodel_or_simulation_package = model\nmodel_name = flow\n\nBlock options\n--------------------\nbudget_filerecord\n{internal}\n([('flow.bud',)])\n\nhead_filerecord\n{internal}\n([('flow.hds',)])\n\n\nBlock period\n--------------------\nsaverecord\n{internal}\n([('HEAD', 'ALL', None) ('BUDGET', 'ALL', None)])\n\nprintrecord\n{internal}\n([('HEAD', 'ALL', None)])\n\n\n\nwriting simulation...\n  writing simulation name file...\n  writing simulation tdis package...\n  writing solution package ims_-1...\n  writing model flow...\n    writing model name file...\n    writing package dis...\n    writing package ic...\n    writing package chd_0...\n    writing package npf...\n    writing package oc...\n\n\n\nObservación.\nLa celda anterior genera el archivo flow.oc con los datos para la salida como sigue:\n# File generated by Flopy version 3.9.2 on 04/26/2025 at 11:36:03.\nBEGIN options\n  BUDGET  FILEOUT  flow.bud\n  HEAD  FILEOUT  flow.hds\nEND options\n\nBEGIN period  1\n  SAVE  HEAD  ALL\n  SAVE  BUDGET  ALL\n  PRINT  HEAD  ALL\nEND period  1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>MODFLOW 6: modelo GWF.</span>"
    ]
  },
  {
    "objectID": "02_MF6_GWF_paq.html#paso-7.-ejecución-de-la-simulación.",
    "href": "02_MF6_GWF_paq.html#paso-7.-ejecución-de-la-simulación.",
    "title": "3  MODFLOW 6: modelo GWF.",
    "section": "5.8 Paso 7. Ejecución de la simulación.",
    "text": "5.8 Paso 7. Ejecución de la simulación.\nEn este punto tenemos con toda la información de entrada en los siguientes archivos:\n\nflow.tdis: datos para la discretización temporal.\nflow.ims: datos para la solución numérica.\nflow.dis: datos para la discretización espacial.\nflow.ic: datos para las condiciones iniciales.\nflow.chd: datos para las condiciones de frontera.\nflow.npf: datos para los flujos entre celdas.\nflow.oc: datos para la salida de los resultados.\nflow.nam: datos para el modelo GWF, informa de los paquetes que se usan.\nmfsim.nam: datos de la simulación completa, informa de las componentes que se usan.\n\nPodemos ejecutar la simulación como sigue:\n\no_sim.run_simulation(silent=False)\n\nFloPy is using the following executable to run the model: ..\\..\\..\\..\\mf6\\windows\\mf6.exe\n                                   MODFLOW 6\n                U.S. GEOLOGICAL SURVEY MODULAR HYDROLOGIC MODEL\n                            VERSION 6.6.1 02/10/2025\n\n   MODFLOW 6 compiled Feb 10 2025 17:37:25 with Intel(R) Fortran Intel(R) 64\n   Compiler Classic for applications running on Intel(R) 64, Version 2021.7.0\n                             Build 20220726_000000\n\nThis software has been approved for release by the U.S. Geological \nSurvey (USGS). Although the software has been subjected to rigorous \nreview, the USGS reserves the right to update the software as needed \npursuant to further analysis and review. No warranty, expressed or \nimplied, is made by the USGS or the U.S. Government as to the \nfunctionality of the software and related material nor shall the \nfact of release constitute any such warranty. Furthermore, the \nsoftware is released on condition that neither the USGS nor the U.S. \nGovernment shall be held liable for any damages resulting from its \nauthorized or unauthorized use. Also refer to the USGS Water \nResources Software User Rights Notice for complete use, copyright, \nand distribution information.\n\n \n MODFLOW runs in SEQUENTIAL mode\n \n Run start date and time (yyyy/mm/dd hh:mm:ss): 2025/05/18 13:17:59\n \n Writing simulation list file: mfsim.lst\n Using Simulation name file: mfsim.nam\n \n    Solving:  Stress period:     1    Time step:     1\n \n Run end date and time (yyyy/mm/dd hh:mm:ss): 2025/05/18 13:17:59\n Elapsed run time:  0.202 Seconds\n \n Normal termination of simulation.\n\n\n(True, [])\n\n\n\nObservaciones.\nLa ejecución de la simulación genera los siguientes archivos:\n\nflow.dis.grb: información de la malla con todos los datos de las coordenadas, conectividad y otros (binario).\nflow.bud: datos del budget (binario).\nflow.hds: datos de la carga hidráulica (binario).\nflow.lst: archivo de listado con información de los resultados del modelo GWF.\nmfsim.lst: archivo de listado con información general de la simulación.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>MODFLOW 6: modelo GWF.</span>"
    ]
  },
  {
    "objectID": "02_MF6_GWF_paq.html#paso-8.-recuperación-y-visualización-de-los-resultados.",
    "href": "02_MF6_GWF_paq.html#paso-8.-recuperación-y-visualización-de-los-resultados.",
    "title": "3  MODFLOW 6: modelo GWF.",
    "section": "5.9 Paso 8. Recuperación y visualización de los resultados.",
    "text": "5.9 Paso 8. Recuperación y visualización de los resultados.\n\n5.9.1 Recuperación de la carga hidráulica.\nPara analizar los resultados generados por la simulación almacenados en los archivos descritos antes usaremos las herramientas que ofrece Flopy.\n\nObjetos, funciones y archivos a usar.\n\nPrimero recuperamos la carga hidráulica almacenada en el archivo flow.hds usando un objeto de la clase flopy.utils.HeadFile.\nPosteriormente, con la función get_data obtenemos un arreglo de numpy con la información correspondiente:\n\n\n\n# construimos el nombre con la ruta y extensión correcta\nheadfile = os.path.join(f\"{sim_ws}\", f\"{sim_name}.hds\")\n\n# Objeto para obtener y manipular arreglos o series de tiempo de arreglos con datos\n# de una o más celdas con información del archivo binario de la carga hidráulica.\nhds = flopy.utils.HeadFile(headfile)\n\n# Solo se obtiene la capa 0, cuando no se pone ningún valor en el parámetro mlay se obtienen todas las capas\nhead = hds.get_data(mflay=0)\n\n# Imprimimos la información\nprint(\"head array\")\nxmf6.info_array(head)\nprint(\"\\nHEAD:\\n\", head)\n\nhead array\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : float64 \n dim   : 2 \n shape : (10, 15) \n size(bytes) : 8 \n size(elements) : 150\n\nHEAD:\n [[10.          9.64285714  9.28571428  8.92857142  8.57142856  8.21428571\n   7.85714285  7.5         7.14285714  6.78571427  6.42857141  6.07142855\n   5.71428569  5.35714284  5.        ]\n [10.          9.64285714  9.28571428  8.92857142  8.57142856  8.2142857\n   7.85714286  7.50000001  7.14285715  6.78571428  6.42857141  6.07142855\n   5.71428569  5.35714285  5.        ]\n [10.          9.64285714  9.28571428  8.92857143  8.57142857  8.21428571\n   7.85714285  7.5         7.14285715  6.78571428  6.42857142  6.07142856\n   5.71428571  5.35714286  5.        ]\n [10.          9.64285714  9.28571429  8.92857143  8.57142858  8.21428572\n   7.85714286  7.5         7.14285715  6.78571429  6.42857143  6.07142858\n   5.71428572  5.35714286  5.        ]\n [10.          9.64285715  9.28571429  8.92857143  8.57142858  8.21428572\n   7.85714287  7.5         7.14285715  6.7857143   6.42857145  6.07142859\n   5.71428573  5.35714287  5.        ]\n [10.          9.64285715  9.28571429  8.92857144  8.57142858  8.21428572\n   7.85714287  7.50000001  7.14285715  6.7857143   6.42857145  6.07142859\n   5.71428573  5.35714287  5.        ]\n [10.          9.64285715  9.28571429  8.92857143  8.57142857  8.21428571\n   7.85714286  7.50000001  7.14285715  6.78571429  6.42857144  6.07142859\n   5.71428572  5.35714286  5.        ]\n [10.          9.64285714  9.28571429  8.92857143  8.57142857  8.21428571\n   7.85714285  7.5         7.14285714  6.78571428  6.42857142  6.07142858\n   5.71428572  5.35714285  5.        ]\n [10.          9.64285714  9.28571428  8.92857142  8.57142857  8.21428571\n   7.85714284  7.49999998  7.14285712  6.78571427  6.42857141  6.07142856\n   5.71428572  5.35714286  5.        ]\n [10.          9.64285714  9.28571428  8.92857142  8.57142857  8.21428571\n   7.85714284  7.49999998  7.14285712  6.78571426  6.42857141  6.07142855\n   5.7142857   5.35714285  5.        ]]\n\n\n\n\n5.9.2 Visualización de la carga hidráulica.\nFlopy también contiene herramientas para visualizar los resultados. Se combina con la biblioteca matplotlib para generar gráficas XY, mapas de color, contornos, vectores, entre otros.\n\nObjetos y funciones a usar.\n\nPara visualizar estos resultados usamos un objeto de la clase flopy.plot.PlotMapView con la cual se crea un mapa del modelo y delega la funcionalidad de la graficación de acuerdo con el tipo de malla del modelo.\nAgregamos a esta visualización lo siguiente:\n\nplot_array() : genera un mapa de color con los datos de la carga cidráulica.\ncontour_array() : genera contornos con los datos de la carga cidráulica.\nplot_grid : dibuja la malla del modelo.\n\nUsamos también la función xmf6.cax() para obtener un espacio adecuado para la barra de color.\n\n\n\nfig = plt.figure()\nax = fig.gca() # Ejes donde se hará la graficación\n\n# Mapa visual del modelo. En este caso el modelo es 'o_gwf'.\nmapview = flopy.plot.PlotMapView(model=o_gwf, ax=ax)\n\n# Visualización de la carga hidráulica usando un mapa de color.\ncb = mapview.plot_array(head, cmap=\"viridis\", vmin=np.nanmin(head), vmax=np.nanmax(head))\n\n# Visualización de la carga hidráulica usando contornos.\nct = mapview.contour_array(head, levels=20, linewidths=1.0, colors='silver')\n\n# Visualización de la malla, con una transparencia.\nmapview.plot_grid(linewidths=0.5, alpha =0.5)\n\n# Barra de color.\nplt.colorbar(cb, ax=ax, label=\"h (m)\", cax = xmf6.vis.cax(ax, cb))\n\n# Personalización de la gráfica.\nax.set_title(\"Carga hidráulica (capa 1)\")\nax.set_xlabel(\"X (m)\")\nax.set_ylabel(\"Y (m)\")\nax.set_aspect('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n5.9.3 Recuperación de la descarga específica.\nTambién es posible calcular y graficar la descarga específica, la cual se define como\n\\[\nq = -K \\nabla h\n\\]\nDonde: * \\(q\\) : vector de descarga específica (flujo Darciano) [L/T]. * \\(K\\) : conductividad hidráulica del medio [L/T]. * \\(\\nabla h\\): gradiente hidráulico (variación espacial de la carga hidráulica).\n\nObjetos, funciones y archivos a usar.\n\nEn este caso usaremos un objeto de la clase flopy.utils.CellBudgetFile.\nLuego para obtener los datos usamos la función get_data(). En este caso se requiere del parámetro text = \"DATA-SPDIS\" que indica que se obtendrá la descarga específica.\nPara que esto funcione, es necesario agregar el parámetro save_specific_discharge = True en el paquete NPF (Node Property Flow).\nLa función get_data regresará una lista que contiene un solo elemento, el cual es un arreglo de tipo numpy.rec.recarray.\n\n\n\n# construimos el nombre con la ruta y extensión correcta\nbudfile = os.path.join(f\"{sim_ws}\", f\"{sim_name}.bud\")\n\n# Objeto para obtener y manipular arreglos o series de tiempo de arreglos con datos\n# de una o más celdas con información del archivo binario del budget.\nbud  = flopy.utils.CellBudgetFile(budfile)\n\n# Cargar resultados de la descarga específica\nspdis = bud.get_data(text=\"DATA-SPDIS\")[0]\n\n# Imprimimos la información\nprint(\"spdis array:\", spdis.shape)\nxmf6.info_array(spdis)\n\nspdis array: (150,)\n tipo  : &lt;class 'numpy.rec.recarray'&gt; \n dtype : (numpy.record, [('node', '&lt;i4'), ('node2', '&lt;i4'), ('q', '&lt;f8'), ('qx', '&lt;f8'), ('qy', '&lt;f8'), ('qz', '&lt;f8')]) \n dim   : 1 \n shape : (150,) \n size(bytes) : 40 \n size(elements) : 150\n\n\n\nObservaciones.\n\nEl objeto spdis es de tipo numpy.rec.recarray con 6 columnas de información: node, node2, q, qx, qy, qz.\nCada renglón de este arreglo corresponde a la información de una celda (en este caso \\(15 \\times 10 =  150\\) celdas).\n\n\n\n\n\n\n\n\n\nColumna\nDescripción\nUnidades\n\n\n\n\nnode\nÍndice del nodo origen: celda desde la que sale el flujo\n—\n\n\nnode2\nÍndice del nodo destino: celda hacia la que va el flujo\n—\n\n\nq\nCaudal total entre node y node2\nm³/d\n\n\nqx\nComponente del flujo en dirección \\(x\\)\nm³/d\n\n\nqy\nComponente del flujo en dirección \\(y\\)\nm³/d\n\n\nqz\nComponente del flujo en dirección \\(z\\) (positivo hacia abajo)\nm³/d\n\n\n\n\nPodemos ver el contenido de este arreglo como sigue:\n\n\n\nprint(\"\\nSPDIS:\\n\", spdis)\n\n\nSPDIS:\n [(  1,   1, 0., 0.35714286,  0.00000000e+00, 0.)\n (  2,   2, 0., 0.35714286,  5.47633050e-10, 0.)\n (  3,   3, 0., 0.35714286,  7.50866036e-12, 0.)\n (  4,   4, 0., 0.35714286, -1.00981623e-09, 0.)\n (  5,   5, 0., 0.35714286, -1.53560009e-09, 0.)\n (  6,   6, 0., 0.35714285, -8.93553675e-10, 0.)\n (  7,   7, 0., 0.35714285,  2.87018409e-09, 0.)\n (  8,   8, 0., 0.35714286,  1.05430837e-08, 0.)\n (  9,   9, 0., 0.35714286,  1.47557371e-08, 0.)\n ( 10,  10, 0., 0.35714286,  8.12601186e-09, 0.)\n ( 11,  11, 0., 0.35714286,  4.20858903e-10, 0.)\n ( 12,  12, 0., 0.35714286,  1.66894321e-09, 0.)\n ( 13,  13, 0., 0.35714285,  4.89590590e-09, 0.)\n ( 14,  14, 0., 0.35714284,  5.71419445e-09, 0.)\n ( 15,  15, 0., 0.35714284,  0.00000000e+00, 0.)\n ( 16,  16, 0., 0.35714286,  0.00000000e+00, 0.)\n ( 17,  17, 0., 0.35714286,  5.43539436e-10, 0.)\n ( 18,  18, 0., 0.35714286,  8.54491589e-10, 0.)\n ( 19,  19, 0., 0.35714286,  2.06802397e-09, 0.)\n ( 20,  20, 0., 0.35714286,  3.72881459e-09, 0.)\n ( 21,  21, 0., 0.35714285,  3.38642092e-09, 0.)\n ( 22,  22, 0., 0.35714285,  1.03656950e-09, 0.)\n ( 23,  23, 0., 0.35714285,  1.75400272e-09, 0.)\n ( 24,  24, 0., 0.35714286,  6.03943651e-09, 0.)\n ( 25,  25, 0., 0.35714287,  6.14190743e-09, 0.)\n ( 26,  26, 0., 0.35714286,  3.57975916e-09, 0.)\n ( 27,  27, 0., 0.35714286,  6.56130039e-09, 0.)\n ( 28,  28, 0., 0.35714285,  9.53989865e-09, 0.)\n ( 29,  29, 0., 0.35714285,  7.52138662e-09, 0.)\n ( 30,  30, 0., 0.35714285,  0.00000000e+00, 0.)\n ( 31,  31, 0., 0.35714286,  0.00000000e+00, 0.)\n ( 32,  32, 0., 0.35714286,  6.91943391e-10, 0.)\n ( 33,  33, 0., 0.35714286,  1.86103044e-09, 0.)\n ( 34,  34, 0., 0.35714286,  4.83698237e-09, 0.)\n ( 35,  35, 0., 0.35714286,  8.76451445e-09, 0.)\n ( 36,  36, 0., 0.35714286,  9.74681047e-09, 0.)\n ( 37,  37, 0., 0.35714286,  4.02223854e-09, 0.)\n ( 38,  38, 0., 0.35714285, -3.16989590e-09, 0.)\n ( 39,  39, 0., 0.35714286, -1.20540644e-09, 0.)\n ( 40,  40, 0., 0.35714286,  6.99057878e-09, 0.)\n ( 41,  41, 0., 0.35714286,  1.08003615e-08, 0.)\n ( 42,  42, 0., 0.35714286,  1.34577243e-08, 0.)\n ( 43,  43, 0., 0.35714285,  1.34282678e-08, 0.)\n ( 44,  44, 0., 0.35714285,  8.25992919e-09, 0.)\n ( 45,  45, 0., 0.35714286,  0.00000000e+00, 0.)\n ( 46,  46, 0., 0.35714286,  0.00000000e+00, 0.)\n ( 47,  47, 0., 0.35714286,  1.39541267e-09, 0.)\n ( 48,  48, 0., 0.35714286,  2.75352452e-09, 0.)\n ( 49,  49, 0., 0.35714285,  3.49437812e-09, 0.)\n ( 50,  50, 0., 0.35714285,  3.80157950e-09, 0.)\n ( 51,  51, 0., 0.35714286,  5.19847188e-09, 0.)\n ( 52,  52, 0., 0.35714286,  5.56624391e-09, 0.)\n ( 53,  53, 0., 0.35714286,  1.45992685e-09, 0.)\n ( 54,  54, 0., 0.35714285,  5.92713878e-10, 0.)\n ( 55,  55, 0., 0.35714286,  8.73039330e-09, 0.)\n ( 56,  56, 0., 0.35714286,  1.47507939e-08, 0.)\n ( 57,  57, 0., 0.35714286,  1.49993009e-08, 0.)\n ( 58,  58, 0., 0.35714286,  1.11664762e-08, 0.)\n ( 59,  59, 0., 0.35714286,  5.95146332e-09, 0.)\n ( 60,  60, 0., 0.35714286,  0.00000000e+00, 0.)\n ( 61,  61, 0., 0.35714285,  0.00000000e+00, 0.)\n ( 62,  62, 0., 0.35714285,  1.48180401e-09, 0.)\n ( 63,  63, 0., 0.35714286,  2.84630985e-09, 0.)\n ( 64,  64, 0., 0.35714286,  2.11817763e-09, 0.)\n ( 65,  65, 0., 0.35714286, -1.27107391e-09, 0.)\n ( 66,  66, 0., 0.35714286, -2.88448909e-09, 0.)\n ( 67,  67, 0., 0.35714286,  1.54385305e-09, 0.)\n ( 68,  68, 0., 0.35714286,  4.45305082e-09, 0.)\n ( 69,  69, 0., 0.35714285,  2.14465024e-09, 0.)\n ( 70,  70, 0., 0.35714285,  3.12278559e-09, 0.)\n ( 71,  71, 0., 0.35714285,  7.03745329e-09, 0.)\n ( 72,  72, 0., 0.35714286,  7.94326427e-09, 0.)\n ( 73,  73, 0., 0.35714286,  4.83928586e-09, 0.)\n ( 74,  74, 0., 0.35714287,  2.62405475e-09, 0.)\n ( 75,  75, 0., 0.35714287,  0.00000000e+00, 0.)\n ( 76,  76, 0., 0.35714285,  0.00000000e+00, 0.)\n ( 77,  77, 0., 0.35714285, -1.52249768e-10, 0.)\n ( 78,  78, 0., 0.35714286, -4.79487561e-10, 0.)\n ( 79,  79, 0., 0.35714286, -1.24683552e-09, 0.)\n ( 80,  80, 0., 0.35714286, -2.99411163e-09, 0.)\n ( 81,  81, 0., 0.35714285, -5.73222803e-09, 0.)\n ( 82,  82, 0., 0.35714285, -3.64090491e-09, 0.)\n ( 83,  83, 0., 0.35714286,  1.97418881e-09, 0.)\n ( 84,  84, 0., 0.35714286,  2.17832863e-10, 0.)\n ( 85,  85, 0., 0.35714285, -4.28550528e-09, 0.)\n ( 86,  86, 0., 0.35714285, -4.40030812e-09, 0.)\n ( 87,  87, 0., 0.35714286, -1.86558724e-09, 0.)\n ( 88,  88, 0., 0.35714286, -4.82911977e-09, 0.)\n ( 89,  89, 0., 0.35714287, -4.75692685e-09, 0.)\n ( 90,  90, 0., 0.35714287,  0.00000000e+00, 0.)\n ( 91,  91, 0., 0.35714285,  0.00000000e+00, 0.)\n ( 92,  92, 0., 0.35714286, -1.60843427e-09, 0.)\n ( 93,  93, 0., 0.35714286, -2.96047187e-09, 0.)\n ( 94,  94, 0., 0.35714286, -2.56772736e-09, 0.)\n ( 95,  95, 0., 0.35714286, -5.72208059e-10, 0.)\n ( 96,  96, 0., 0.35714286, -3.13721937e-09, 0.)\n ( 97,  97, 0., 0.35714285, -9.26611987e-09, 0.)\n ( 98,  98, 0., 0.35714285, -7.99172506e-09, 0.)\n ( 99,  99, 0., 0.35714286, -6.16383966e-09, 0.)\n (100, 100, 0., 0.35714286, -8.32303249e-09, 0.)\n (101, 101, 0., 0.35714285, -1.31341396e-08, 0.)\n (102, 102, 0., 0.35714286, -9.14399534e-09, 0.)\n (103, 103, 0., 0.35714287, -5.49348167e-09, 0.)\n (104, 104, 0., 0.35714286, -7.28141591e-09, 0.)\n (105, 105, 0., 0.35714286,  0.00000000e+00, 0.)\n (106, 106, 0., 0.35714286,  0.00000000e+00, 0.)\n (107, 107, 0., 0.35714286, -2.46356535e-09, 0.)\n (108, 108, 0., 0.35714286, -3.95433553e-09, 0.)\n (109, 109, 0., 0.35714286, -3.08912806e-09, 0.)\n (110, 110, 0., 0.35714286,  1.89291249e-10, 0.)\n (111, 111, 0., 0.35714286,  7.32352845e-10, 0.)\n (112, 112, 0., 0.35714286, -7.39661310e-09, 0.)\n (113, 113, 0., 0.35714285, -1.37140770e-08, 0.)\n (114, 114, 0., 0.35714286, -1.39238296e-08, 0.)\n (115, 115, 0., 0.35714286, -9.43181933e-09, 0.)\n (116, 116, 0., 0.35714285, -1.25264670e-08, 0.)\n (117, 117, 0., 0.35714285, -1.39834171e-08, 0.)\n (118, 118, 0., 0.35714286, -3.06157011e-09, 0.)\n (119, 119, 0., 0.35714286, -4.16186641e-10, 0.)\n (120, 120, 0., 0.35714285,  0.00000000e+00, 0.)\n (121, 121, 0., 0.35714286,  0.00000000e+00, 0.)\n (122, 122, 0., 0.35714286, -9.88087834e-10, 0.)\n (123, 123, 0., 0.35714286, -1.73246573e-09, 0.)\n (124, 124, 0., 0.35714285, -3.12913340e-09, 0.)\n (125, 125, 0., 0.35714286, -4.17634727e-09, 0.)\n (126, 126, 0., 0.35714286, -2.74673351e-09, 0.)\n (127, 127, 0., 0.35714287, -3.69824837e-09, 0.)\n (128, 128, 0., 0.35714286, -7.74172815e-09, 0.)\n (129, 129, 0., 0.35714285, -1.20199997e-08, 0.)\n (130, 130, 0., 0.35714285, -1.00885398e-08, 0.)\n (131, 131, 0., 0.35714286, -6.53736354e-09, 0.)\n (132, 132, 0., 0.35714285, -1.19671197e-08, 0.)\n (133, 133, 0., 0.35714285, -8.38436565e-09, 0.)\n (134, 134, 0., 0.35714286, -6.92109925e-10, 0.)\n (135, 135, 0., 0.35714286,  0.00000000e+00, 0.)\n (136, 136, 0., 0.35714286,  0.00000000e+00, 0.)\n (137, 137, 0., 0.35714286,  1.05580966e-09, 0.)\n (138, 138, 0., 0.35714286,  1.68792802e-09, 0.)\n (139, 139, 0., 0.35714286, -9.46094758e-10, 0.)\n (140, 140, 0., 0.35714286, -5.49697710e-09, 0.)\n (141, 141, 0., 0.35714286, -6.10685191e-09, 0.)\n (142, 142, 0., 0.35714286, -3.05696002e-09, 0.)\n (143, 143, 0., 0.35714286, -1.30559563e-09, 0.)\n (144, 144, 0., 0.35714286, -5.58576119e-09, 0.)\n (145, 145, 0., 0.35714285, -1.07803562e-08, 0.)\n (146, 146, 0., 0.35714286, -6.05407369e-09, 0.)\n (147, 147, 0., 0.35714285, -9.17450382e-09, 0.)\n (148, 148, 0., 0.35714285, -1.19560513e-08, 0.)\n (149, 149, 0., 0.35714285, -5.06436226e-09, 0.)\n (150, 150, 0., 0.35714285,  0.00000000e+00, 0.)]\n\n\nPodemos checar cada una de las columnas por separado:\n\nprint(\"\\nnode:\", spdis.node.shape)\nxmf6.info_array(spdis.node)\nprint(spdis.node)\n\nprint(\"\\nnode2:\", spdis.node2.shape)\nxmf6.info_array(spdis.node2)\nprint(spdis.node2)\n\nprint(\"\\nq:\", spdis.q.shape)\nxmf6.info_array(spdis.q)\nprint(spdis.q)\n\nprint(\"\\nqx:\", spdis.qx.shape)\nxmf6.info_array(spdis.qx)\nprint(spdis.qx)\n\nprint(\"\\nqy:\", spdis.qy.shape)\nxmf6.info_array(spdis.qy)\nprint(spdis.qy)\n\nprint(\"\\nqz:\", spdis.qz.shape)\nxmf6.info_array(spdis.qz)\nprint(spdis.qz)\n\n\nnode: (150,)\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : int32 \n dim   : 1 \n shape : (150,) \n size(bytes) : 4 \n size(elements) : 150\n[  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n 145 146 147 148 149 150]\n\nnode2: (150,)\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : int32 \n dim   : 1 \n shape : (150,) \n size(bytes) : 4 \n size(elements) : 150\n[  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n 145 146 147 148 149 150]\n\nq: (150,)\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : float64 \n dim   : 1 \n shape : (150,) \n size(bytes) : 8 \n size(elements) : 150\n[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n 0. 0. 0. 0. 0. 0.]\n\nqx: (150,)\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : float64 \n dim   : 1 \n shape : (150,) \n size(bytes) : 8 \n size(elements) : 150\n[0.35714286 0.35714286 0.35714286 0.35714286 0.35714286 0.35714285\n 0.35714285 0.35714286 0.35714286 0.35714286 0.35714286 0.35714286\n 0.35714285 0.35714284 0.35714284 0.35714286 0.35714286 0.35714286\n 0.35714286 0.35714286 0.35714285 0.35714285 0.35714285 0.35714286\n 0.35714287 0.35714286 0.35714286 0.35714285 0.35714285 0.35714285\n 0.35714286 0.35714286 0.35714286 0.35714286 0.35714286 0.35714286\n 0.35714286 0.35714285 0.35714286 0.35714286 0.35714286 0.35714286\n 0.35714285 0.35714285 0.35714286 0.35714286 0.35714286 0.35714286\n 0.35714285 0.35714285 0.35714286 0.35714286 0.35714286 0.35714285\n 0.35714286 0.35714286 0.35714286 0.35714286 0.35714286 0.35714286\n 0.35714285 0.35714285 0.35714286 0.35714286 0.35714286 0.35714286\n 0.35714286 0.35714286 0.35714285 0.35714285 0.35714285 0.35714286\n 0.35714286 0.35714287 0.35714287 0.35714285 0.35714285 0.35714286\n 0.35714286 0.35714286 0.35714285 0.35714285 0.35714286 0.35714286\n 0.35714285 0.35714285 0.35714286 0.35714286 0.35714287 0.35714287\n 0.35714285 0.35714286 0.35714286 0.35714286 0.35714286 0.35714286\n 0.35714285 0.35714285 0.35714286 0.35714286 0.35714285 0.35714286\n 0.35714287 0.35714286 0.35714286 0.35714286 0.35714286 0.35714286\n 0.35714286 0.35714286 0.35714286 0.35714286 0.35714285 0.35714286\n 0.35714286 0.35714285 0.35714285 0.35714286 0.35714286 0.35714285\n 0.35714286 0.35714286 0.35714286 0.35714285 0.35714286 0.35714286\n 0.35714287 0.35714286 0.35714285 0.35714285 0.35714286 0.35714285\n 0.35714285 0.35714286 0.35714286 0.35714286 0.35714286 0.35714286\n 0.35714286 0.35714286 0.35714286 0.35714286 0.35714286 0.35714286\n 0.35714285 0.35714286 0.35714285 0.35714285 0.35714285 0.35714285]\n\nqy: (150,)\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : float64 \n dim   : 1 \n shape : (150,) \n size(bytes) : 8 \n size(elements) : 150\n[ 0.00000000e+00  5.47633050e-10  7.50866036e-12 -1.00981623e-09\n -1.53560009e-09 -8.93553675e-10  2.87018409e-09  1.05430837e-08\n  1.47557371e-08  8.12601186e-09  4.20858903e-10  1.66894321e-09\n  4.89590590e-09  5.71419445e-09  0.00000000e+00  0.00000000e+00\n  5.43539436e-10  8.54491589e-10  2.06802397e-09  3.72881459e-09\n  3.38642092e-09  1.03656950e-09  1.75400272e-09  6.03943651e-09\n  6.14190743e-09  3.57975916e-09  6.56130039e-09  9.53989865e-09\n  7.52138662e-09  0.00000000e+00  0.00000000e+00  6.91943391e-10\n  1.86103044e-09  4.83698237e-09  8.76451445e-09  9.74681047e-09\n  4.02223854e-09 -3.16989590e-09 -1.20540644e-09  6.99057878e-09\n  1.08003615e-08  1.34577243e-08  1.34282678e-08  8.25992919e-09\n  0.00000000e+00  0.00000000e+00  1.39541267e-09  2.75352452e-09\n  3.49437812e-09  3.80157950e-09  5.19847188e-09  5.56624391e-09\n  1.45992685e-09  5.92713878e-10  8.73039330e-09  1.47507939e-08\n  1.49993009e-08  1.11664762e-08  5.95146332e-09  0.00000000e+00\n  0.00000000e+00  1.48180401e-09  2.84630985e-09  2.11817763e-09\n -1.27107391e-09 -2.88448909e-09  1.54385305e-09  4.45305082e-09\n  2.14465024e-09  3.12278559e-09  7.03745329e-09  7.94326427e-09\n  4.83928586e-09  2.62405475e-09  0.00000000e+00  0.00000000e+00\n -1.52249768e-10 -4.79487561e-10 -1.24683552e-09 -2.99411163e-09\n -5.73222803e-09 -3.64090491e-09  1.97418881e-09  2.17832863e-10\n -4.28550528e-09 -4.40030812e-09 -1.86558724e-09 -4.82911977e-09\n -4.75692685e-09  0.00000000e+00  0.00000000e+00 -1.60843427e-09\n -2.96047187e-09 -2.56772736e-09 -5.72208059e-10 -3.13721937e-09\n -9.26611987e-09 -7.99172506e-09 -6.16383966e-09 -8.32303249e-09\n -1.31341396e-08 -9.14399534e-09 -5.49348167e-09 -7.28141591e-09\n  0.00000000e+00  0.00000000e+00 -2.46356535e-09 -3.95433553e-09\n -3.08912806e-09  1.89291249e-10  7.32352845e-10 -7.39661310e-09\n -1.37140770e-08 -1.39238296e-08 -9.43181933e-09 -1.25264670e-08\n -1.39834171e-08 -3.06157011e-09 -4.16186641e-10  0.00000000e+00\n  0.00000000e+00 -9.88087834e-10 -1.73246573e-09 -3.12913340e-09\n -4.17634727e-09 -2.74673351e-09 -3.69824837e-09 -7.74172815e-09\n -1.20199997e-08 -1.00885398e-08 -6.53736354e-09 -1.19671197e-08\n -8.38436565e-09 -6.92109925e-10  0.00000000e+00  0.00000000e+00\n  1.05580966e-09  1.68792802e-09 -9.46094758e-10 -5.49697710e-09\n -6.10685191e-09 -3.05696002e-09 -1.30559563e-09 -5.58576119e-09\n -1.07803562e-08 -6.05407369e-09 -9.17450382e-09 -1.19560513e-08\n -5.06436226e-09  0.00000000e+00]\n\nqz: (150,)\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : float64 \n dim   : 1 \n shape : (150,) \n size(bytes) : 8 \n size(elements) : 150\n[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n 0. 0. 0. 0. 0. 0.]\n\n\n\n# Extraemos las componentes del flujo en un arreglo 3D para graficación\nqx, qy, qz = flopy.utils.postprocessing.get_specific_discharge(spdis, o_gwf)\n\nprint(\"\\nqx:\", qx.shape)\nxmf6.info_array(qx)\nprint(qx)\n\nprint(\"\\nqy:\", qy.shape)\nxmf6.info_array(qy)\nprint(qy)\n\n\nqx: (1, 10, 15)\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : float64 \n dim   : 3 \n shape : (1, 10, 15) \n size(bytes) : 8 \n size(elements) : 150\n[[[0.35714286 0.35714286 0.35714286 0.35714286 0.35714286 0.35714285\n   0.35714285 0.35714286 0.35714286 0.35714286 0.35714286 0.35714286\n   0.35714285 0.35714284 0.35714284]\n  [0.35714286 0.35714286 0.35714286 0.35714286 0.35714286 0.35714285\n   0.35714285 0.35714285 0.35714286 0.35714287 0.35714286 0.35714286\n   0.35714285 0.35714285 0.35714285]\n  [0.35714286 0.35714286 0.35714286 0.35714286 0.35714286 0.35714286\n   0.35714286 0.35714285 0.35714286 0.35714286 0.35714286 0.35714286\n   0.35714285 0.35714285 0.35714286]\n  [0.35714286 0.35714286 0.35714286 0.35714285 0.35714285 0.35714286\n   0.35714286 0.35714286 0.35714285 0.35714286 0.35714286 0.35714286\n   0.35714286 0.35714286 0.35714286]\n  [0.35714285 0.35714285 0.35714286 0.35714286 0.35714286 0.35714286\n   0.35714286 0.35714286 0.35714285 0.35714285 0.35714285 0.35714286\n   0.35714286 0.35714287 0.35714287]\n  [0.35714285 0.35714285 0.35714286 0.35714286 0.35714286 0.35714285\n   0.35714285 0.35714286 0.35714286 0.35714285 0.35714285 0.35714286\n   0.35714286 0.35714287 0.35714287]\n  [0.35714285 0.35714286 0.35714286 0.35714286 0.35714286 0.35714286\n   0.35714285 0.35714285 0.35714286 0.35714286 0.35714285 0.35714286\n   0.35714287 0.35714286 0.35714286]\n  [0.35714286 0.35714286 0.35714286 0.35714286 0.35714286 0.35714286\n   0.35714286 0.35714285 0.35714286 0.35714286 0.35714285 0.35714285\n   0.35714286 0.35714286 0.35714285]\n  [0.35714286 0.35714286 0.35714286 0.35714285 0.35714286 0.35714286\n   0.35714287 0.35714286 0.35714285 0.35714285 0.35714286 0.35714285\n   0.35714285 0.35714286 0.35714286]\n  [0.35714286 0.35714286 0.35714286 0.35714286 0.35714286 0.35714286\n   0.35714286 0.35714286 0.35714286 0.35714285 0.35714286 0.35714285\n   0.35714285 0.35714285 0.35714285]]]\n\nqy: (1, 10, 15)\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : float64 \n dim   : 3 \n shape : (1, 10, 15) \n size(bytes) : 8 \n size(elements) : 150\n[[[ 0.00000000e+00  5.47633050e-10  7.50866036e-12 -1.00981623e-09\n   -1.53560009e-09 -8.93553675e-10  2.87018409e-09  1.05430837e-08\n    1.47557371e-08  8.12601186e-09  4.20858903e-10  1.66894321e-09\n    4.89590590e-09  5.71419445e-09  0.00000000e+00]\n  [ 0.00000000e+00  5.43539436e-10  8.54491589e-10  2.06802397e-09\n    3.72881459e-09  3.38642092e-09  1.03656950e-09  1.75400272e-09\n    6.03943651e-09  6.14190743e-09  3.57975916e-09  6.56130039e-09\n    9.53989865e-09  7.52138662e-09  0.00000000e+00]\n  [ 0.00000000e+00  6.91943391e-10  1.86103044e-09  4.83698237e-09\n    8.76451445e-09  9.74681047e-09  4.02223854e-09 -3.16989590e-09\n   -1.20540644e-09  6.99057878e-09  1.08003615e-08  1.34577243e-08\n    1.34282678e-08  8.25992919e-09  0.00000000e+00]\n  [ 0.00000000e+00  1.39541267e-09  2.75352452e-09  3.49437812e-09\n    3.80157950e-09  5.19847188e-09  5.56624391e-09  1.45992685e-09\n    5.92713878e-10  8.73039330e-09  1.47507939e-08  1.49993009e-08\n    1.11664762e-08  5.95146332e-09  0.00000000e+00]\n  [ 0.00000000e+00  1.48180401e-09  2.84630985e-09  2.11817763e-09\n   -1.27107391e-09 -2.88448909e-09  1.54385305e-09  4.45305082e-09\n    2.14465024e-09  3.12278559e-09  7.03745329e-09  7.94326427e-09\n    4.83928586e-09  2.62405475e-09  0.00000000e+00]\n  [ 0.00000000e+00 -1.52249768e-10 -4.79487561e-10 -1.24683552e-09\n   -2.99411163e-09 -5.73222803e-09 -3.64090491e-09  1.97418881e-09\n    2.17832863e-10 -4.28550528e-09 -4.40030812e-09 -1.86558724e-09\n   -4.82911977e-09 -4.75692685e-09  0.00000000e+00]\n  [ 0.00000000e+00 -1.60843427e-09 -2.96047187e-09 -2.56772736e-09\n   -5.72208059e-10 -3.13721937e-09 -9.26611987e-09 -7.99172506e-09\n   -6.16383966e-09 -8.32303249e-09 -1.31341396e-08 -9.14399534e-09\n   -5.49348167e-09 -7.28141591e-09  0.00000000e+00]\n  [ 0.00000000e+00 -2.46356535e-09 -3.95433553e-09 -3.08912806e-09\n    1.89291249e-10  7.32352845e-10 -7.39661310e-09 -1.37140770e-08\n   -1.39238296e-08 -9.43181933e-09 -1.25264670e-08 -1.39834171e-08\n   -3.06157011e-09 -4.16186641e-10  0.00000000e+00]\n  [ 0.00000000e+00 -9.88087834e-10 -1.73246573e-09 -3.12913340e-09\n   -4.17634727e-09 -2.74673351e-09 -3.69824837e-09 -7.74172815e-09\n   -1.20199997e-08 -1.00885398e-08 -6.53736354e-09 -1.19671197e-08\n   -8.38436565e-09 -6.92109925e-10  0.00000000e+00]\n  [ 0.00000000e+00  1.05580966e-09  1.68792802e-09 -9.46094758e-10\n   -5.49697710e-09 -6.10685191e-09 -3.05696002e-09 -1.30559563e-09\n   -5.58576119e-09 -1.07803562e-08 -6.05407369e-09 -9.17450382e-09\n   -1.19560513e-08 -5.06436226e-09  0.00000000e+00]]]\n\n\n\n# Coordenadas del centro de celdas para graficación\nx, y, z = o_gwf.modelgrid.xyzcellcenters\n\nprint(\"\\nx:\", x.shape)\nxmf6.info_array(x)\nprint(x)\n\nprint(\"\\ny:\", y.shape)\nxmf6.info_array(y)\nprint(y)\n\n\nx: (10, 15)\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : float64 \n dim   : 2 \n shape : (10, 15) \n size(bytes) : 8 \n size(elements) : 150\n[[ 0.5  1.5  2.5  3.5  4.5  5.5  6.5  7.5  8.5  9.5 10.5 11.5 12.5 13.5\n  14.5]\n [ 0.5  1.5  2.5  3.5  4.5  5.5  6.5  7.5  8.5  9.5 10.5 11.5 12.5 13.5\n  14.5]\n [ 0.5  1.5  2.5  3.5  4.5  5.5  6.5  7.5  8.5  9.5 10.5 11.5 12.5 13.5\n  14.5]\n [ 0.5  1.5  2.5  3.5  4.5  5.5  6.5  7.5  8.5  9.5 10.5 11.5 12.5 13.5\n  14.5]\n [ 0.5  1.5  2.5  3.5  4.5  5.5  6.5  7.5  8.5  9.5 10.5 11.5 12.5 13.5\n  14.5]\n [ 0.5  1.5  2.5  3.5  4.5  5.5  6.5  7.5  8.5  9.5 10.5 11.5 12.5 13.5\n  14.5]\n [ 0.5  1.5  2.5  3.5  4.5  5.5  6.5  7.5  8.5  9.5 10.5 11.5 12.5 13.5\n  14.5]\n [ 0.5  1.5  2.5  3.5  4.5  5.5  6.5  7.5  8.5  9.5 10.5 11.5 12.5 13.5\n  14.5]\n [ 0.5  1.5  2.5  3.5  4.5  5.5  6.5  7.5  8.5  9.5 10.5 11.5 12.5 13.5\n  14.5]\n [ 0.5  1.5  2.5  3.5  4.5  5.5  6.5  7.5  8.5  9.5 10.5 11.5 12.5 13.5\n  14.5]]\n\ny: (10, 15)\n tipo  : &lt;class 'numpy.ndarray'&gt; \n dtype : float64 \n dim   : 2 \n shape : (10, 15) \n size(bytes) : 8 \n size(elements) : 150\n[[9.5 9.5 9.5 9.5 9.5 9.5 9.5 9.5 9.5 9.5 9.5 9.5 9.5 9.5 9.5]\n [8.5 8.5 8.5 8.5 8.5 8.5 8.5 8.5 8.5 8.5 8.5 8.5 8.5 8.5 8.5]\n [7.5 7.5 7.5 7.5 7.5 7.5 7.5 7.5 7.5 7.5 7.5 7.5 7.5 7.5 7.5]\n [6.5 6.5 6.5 6.5 6.5 6.5 6.5 6.5 6.5 6.5 6.5 6.5 6.5 6.5 6.5]\n [5.5 5.5 5.5 5.5 5.5 5.5 5.5 5.5 5.5 5.5 5.5 5.5 5.5 5.5 5.5]\n [4.5 4.5 4.5 4.5 4.5 4.5 4.5 4.5 4.5 4.5 4.5 4.5 4.5 4.5 4.5]\n [3.5 3.5 3.5 3.5 3.5 3.5 3.5 3.5 3.5 3.5 3.5 3.5 3.5 3.5 3.5]\n [2.5 2.5 2.5 2.5 2.5 2.5 2.5 2.5 2.5 2.5 2.5 2.5 2.5 2.5 2.5]\n [1.5 1.5 1.5 1.5 1.5 1.5 1.5 1.5 1.5 1.5 1.5 1.5 1.5 1.5 1.5]\n [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]]\n\n\n\n\n5.9.4 Visualización de la descarga específica.\nEn este caso, se usan los mismos objetos que en la graficación de la carga hidráulica y solo se agregan los vectors de la descarga hidráulica.\n\nObservación.\nPara dibujar los vectores usamos la función quiver() de matplotlib, pues ya tenemos los arreglos x, y, qx y qy en el formato adecuado para graficarlos en 2D.\n\n\nfig = plt.figure()\nax =fig.gca()\nmapview = flopy.plot.PlotMapView(model=o_gwf, ax=ax)\n\n# Visualización de la carga hidráulica usando un mapa de color.\ncb = mapview.plot_array(head, cmap=\"viridis\", alpha=0.5)\n\n# Visualización de los vectores de la descarga específica.\nax.quiver(x, y, qx[0], qy[0], scale=10, color='k', pivot='middle')\n\n# Visualización de la malla, con una transparencia.\nmapview.plot_grid(linewidths=0.5, alpha =0.5)\n\n# Barra de color.\nplt.colorbar(cb, ax=ax, label=\"h (m)\", cax = xmf6.vis.cax(ax, cb))\n\n# Personalización de la gráfica.\nax.set_title(\"Vectores de flujo sobre carga hidráulica (capa 1)\")\nax.set_xlabel(\"X (m)\")\nax.set_ylabel(\"Y (m)\")\nax.set_aspect('equal')\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>MODFLOW 6: modelo GWF.</span>"
    ]
  },
  {
    "objectID": "03_MF6_GWF_v1.html",
    "href": "03_MF6_GWF_v1.html",
    "title": "4  MODFLOW 6: simulación de flujo v 1.0",
    "section": "",
    "text": "4.1 Resumen.\nSe realiza una simulación de flujo en dos dimensiones explicando paso a paso el proceso, similar a lo realizado en la notebook 02_MF6_GWF_paq.ipynb pero con una conductividad hidráulica variable. Adicionalmente, se encapsulan en una función de python varias acciones para hacer más modular la simulación.\nMODFLOW 6: simulación de flujo v 1.0 by Luis M. de la Cruz Salas (2025) is licensed under Attribution-ShareAlike 4.0 International.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MODFLOW 6: simulación de flujo v 1.0</span>"
    ]
  },
  {
    "objectID": "03_MF6_GWF_v1.html#paso-0.-importación-de-bibliotecas-y-módulos.",
    "href": "03_MF6_GWF_v1.html#paso-0.-importación-de-bibliotecas-y-módulos.",
    "title": "4  MODFLOW 6: simulación de flujo v 1.0",
    "section": "6.1 Paso 0. Importación de bibliotecas y módulos.",
    "text": "6.1 Paso 0. Importación de bibliotecas y módulos.\nDebemos incluir todas las bibliotecas que se van a usar. En este caso vamos a incluir el módulo gwf_build_1 que contiene las funciones que se describen en este documento.\n\nimport flopy\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\nimport xmf6\nfrom gwf_model import build",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MODFLOW 6: simulación de flujo v 1.0</span>"
    ]
  },
  {
    "objectID": "03_MF6_GWF_v1.html#paso-1.-parámetros-de-la-simulación.",
    "href": "03_MF6_GWF_v1.html#paso-1.-parámetros-de-la-simulación.",
    "title": "4  MODFLOW 6: simulación de flujo v 1.0",
    "section": "6.2 Paso 1. Parámetros de la simulación.",
    "text": "6.2 Paso 1. Parámetros de la simulación.\nCon base en lo realizado en la notebook 02_MF6_GWF_paq.ipynb, se define una función con la secuencia de pasos necesaria para construir el modelo GWF. Esta función tiene la siguiente firma:\ndef build(init, time, mesh, ic_data, chd_data, k_data):\nLa función build()recibe los siguientes parámetros:\n\ninit. Parámetros de configuración de la simulación (nombre del ejecutable, nombre del modelo, espacio de trabajo, etc).\ntime. Parámetros para la discretización temporal.\nmesh. Parámetros para la discretización espacial.\nic_data. Parámetros para las condiciones iniciales.\nchd_data. Parámetros para las condiciones de frontera.\nk_data. Parámetros para las propiedades del flujo.\n\nEstos parámetros se definen en diccionarios y en arreglos como se muesta a continuación.\n\n# --- Datos para la configuración de la simulación --- \n# Opciones de SO's: linux, macos, macosarm, windows\ninit = {\n    'exe_name' : \"C:\\\\Users\\\\luiggi\\\\Documents\\\\GitSites\\\\xmf6\\\\mf6\\\\windows\\\\mf6\",\n#    'exe_name' : \"../../../mf6/macosarm/mf6\",\n    'sim_name' : \"flow\",\n    'sim_ws' : \"sandbox3\"\n}\n\n# --- Datos para la discretización temporal ---\ntime = {\n    'units': \"DAYS\",\n    'nper' : 1,\n    'perioddata': [(1.0, 1, 1.0)]\n}\n\n# --- Datos para la discretización espacial ---\ndis = {\n    'nlay': 1, \n    'nrow': 20, \n    'ncol': 30,\n    'delr': 0.5, \n    'delc': 0.5, \n    'top' : 0.0, \n    'botm': -1.0 \n}\n\n# --- Datos para las condiciones iniciales ---\nic_data = {\n    'strt': 10\n}\n\nSe puede ver el contenido de los diccionarios como sigue:\n\nprint(init)\nprint(time)\nprint(dis)\nprint(ic_data)\n\n{'exe_name': 'C:\\\\Users\\\\luiggi\\\\Documents\\\\GitSites\\\\xmf6\\\\mf6\\\\windows\\\\mf6', 'sim_name': 'flow', 'sim_ws': 'sandbox3'}\n{'units': 'DAYS', 'nper': 1, 'perioddata': [(1.0, 1, 1.0)]}\n{'nlay': 1, 'nrow': 20, 'ncol': 30, 'delr': 0.5, 'delc': 0.5, 'top': 0.0, 'botm': -1.0}\n{'strt': 10}\n\n\nPara los datos de las condiciones de frontera creamos listas y arreglos de numpy como se muestra a continuación:\n\n# --- Datos para las condiciones de frontera ---\nchd_data = []\nfor row in range(dis['nrow']):\n    chd_data.append([(0, row, 0), 10.0])       # Condición en la pared izquierda\n    chd_data.append([(0, row, dis['ncol'] - 1), 5.0]) # Condición en la pared derecha\n\n#print(chd_data)\n\n\n# --- Datos para las propiedades de flujo ---\n# Creamos un arreglo de conductividad hidráulica para toda la malla\nk_data = np.random.rand(dis['nlay'], dis['nrow'], dis['ncol'])*1.0 \n    \n# Asignamos una conductividad constante en una sección del dominio\nk_data[:,5:15,10:20] = 0.1\n\n#print(k_data)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MODFLOW 6: simulación de flujo v 1.0</span>"
    ]
  },
  {
    "objectID": "03_MF6_GWF_v1.html#paso-2.-función-build.",
    "href": "03_MF6_GWF_v1.html#paso-2.-función-build.",
    "title": "4  MODFLOW 6: simulación de flujo v 1.0",
    "section": "6.3 Paso 2. Función build().",
    "text": "6.3 Paso 2. Función build().\nLa función build() define la siguiente secuencia de pasos (véase la sección Paquetes en la notebook 00_MF6_Intro.ipynb):\n\nInicialización de la simulación.\nComponentes:\n\nTiempos de simulación.\nSolucionador numérico.\nModelo GWF.\n\nPaquetes:\n\nDiscretización espacial (DIS).\nCondiciones iniciales (IC).\nCondiciones de frontera (CHD).\nPropiedades de flujo (NPF).\nConfiguración de la salida (OC).\n\n\nLa función regresa un objeto para la simulación (o_sim) y un objeto del modelo GWF (o_gwf).\ndef build(init, time, mesh, ic_data, chd_data, k_data):\n\n    ...\n\n    return o_sim, o_gwf\nLa implementación de la función se puede ver el archivo gwf_model_1.py.\nEjecutamos la función como sigue:\n\n# --- Construcción de la simulación y del modelo GWF ---\no_sim, o_gwf = build(init, time, dis, ic_data, chd_data, k_data)\n\n\n# --- Impresión del estado de la simulación ---\n#print(o_sim)\n\n\n# --- Impresión del estado del modelo GWF ---\n#print(o_gwf)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MODFLOW 6: simulación de flujo v 1.0</span>"
    ]
  },
  {
    "objectID": "03_MF6_GWF_v1.html#paso-3.-escritura-de-archivos.",
    "href": "03_MF6_GWF_v1.html#paso-3.-escritura-de-archivos.",
    "title": "4  MODFLOW 6: simulación de flujo v 1.0",
    "section": "6.4 Paso 3. Escritura de archivos.",
    "text": "6.4 Paso 3. Escritura de archivos.\nA través del objeto de la simulación, o_sim, escribimos los archivos de entrada para MODFLOW 6:\n\n# --- Escribimos los archivos ---\no_sim.write_simulation()\n\nwriting simulation...\n  writing simulation name file...\n  writing simulation tdis package...\n  writing solution package ims_-1...\n  writing model flow...\n    writing model name file...\n    writing package dis...\n    writing package ic...\n    writing package chd_0...\nINFORMATION: maxbound in ('gwf6', 'chd', 'dimensions') changed to 40 based on size of stress_period_data\n    writing package npf...\n    writing package oc...",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MODFLOW 6: simulación de flujo v 1.0</span>"
    ]
  },
  {
    "objectID": "03_MF6_GWF_v1.html#paso-4.-ejecución-de-la-simulación.",
    "href": "03_MF6_GWF_v1.html#paso-4.-ejecución-de-la-simulación.",
    "title": "4  MODFLOW 6: simulación de flujo v 1.0",
    "section": "6.5 Paso 4. Ejecución de la simulación.",
    "text": "6.5 Paso 4. Ejecución de la simulación.\nA través del objeto de la simulación, o_sim, ejecutamos la simulación:\n\n# --- ejecutamos la simulación ---\no_sim.run_simulation(silent=False)\n\nFloPy is using the following executable to run the model: ..\\..\\..\\..\\mf6\\windows\\mf6.exe\n                                   MODFLOW 6\n                U.S. GEOLOGICAL SURVEY MODULAR HYDROLOGIC MODEL\n                            VERSION 6.6.1 02/10/2025\n\n   MODFLOW 6 compiled Feb 10 2025 17:37:25 with Intel(R) Fortran Intel(R) 64\n   Compiler Classic for applications running on Intel(R) 64, Version 2021.7.0\n                             Build 20220726_000000\n\nThis software has been approved for release by the U.S. Geological \nSurvey (USGS). Although the software has been subjected to rigorous \nreview, the USGS reserves the right to update the software as needed \npursuant to further analysis and review. No warranty, expressed or \nimplied, is made by the USGS or the U.S. Government as to the \nfunctionality of the software and related material nor shall the \nfact of release constitute any such warranty. Furthermore, the \nsoftware is released on condition that neither the USGS nor the U.S. \nGovernment shall be held liable for any damages resulting from its \nauthorized or unauthorized use. Also refer to the USGS Water \nResources Software User Rights Notice for complete use, copyright, \nand distribution information.\n\n \n MODFLOW runs in SEQUENTIAL mode\n \n Run start date and time (yyyy/mm/dd hh:mm:ss): 2025/05/18 16:33:31\n \n Writing simulation list file: mfsim.lst\n Using Simulation name file: mfsim.nam\n \n    Solving:  Stress period:     1    Time step:     1\n \n Run end date and time (yyyy/mm/dd hh:mm:ss): 2025/05/18 16:33:31\n Elapsed run time:  0.122 Seconds\n \n Normal termination of simulation.\n\n\n(True, [])",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MODFLOW 6: simulación de flujo v 1.0</span>"
    ]
  },
  {
    "objectID": "03_MF6_GWF_v1.html#paso-5.-recuperación-de-los-resultados.",
    "href": "03_MF6_GWF_v1.html#paso-5.-recuperación-de-los-resultados.",
    "title": "4  MODFLOW 6: simulación de flujo v 1.0",
    "section": "6.6 Paso 5. Recuperación de los resultados.",
    "text": "6.6 Paso 5. Recuperación de los resultados.\nLos datos los vamos a recuperar de los archivos generados por la simualción, en este caso de flow.hds y flow.bud.\n\nLa carga hidráulica se almacenará en el arreglo head.\nLa descarga específica se almacenará en los arreglos qx, qy y qz.\n\n\n### --- Recuperación de la carga hidráulica ---\n\n# Construimos el nombre con la ruta y extensión correcta\nheadfile = os.path.join(f\"{init[\"sim_ws\"]}\", f\"{init[\"sim_name\"]}.hds\")\n\n# Objeto para obtener y manipular arreglos o series de tiempo de arreglos con datos\n# de una o más celdas con información del archivo binario de la carga hidráulica.\nhds = flopy.utils.HeadFile(headfile)\n\n# Solo se obtiene la capa 0, cuando no se pone ningún valor en el parámetro mlay se obtienen todas las capas\nhead = hds.get_data(mflay=0)\n\n### --- Recuperación de la descarga específica ---\n\n# Construimos el nombre con la ruta y extensión correcta\nbudfile = os.path.join(f\"{init[\"sim_ws\"]}\", f\"{init[\"sim_name\"]}.bud\")\n\n# Objeto para obtener y manipular arreglos o series de tiempo de arreglos con datos\n# de una o más celdas con información del archivo binario del budget.\nbud  = flopy.utils.CellBudgetFile(budfile)\n\n# Cargamos resultados de la descarga específica\nspdis = bud.get_data(text=\"DATA-SPDIS\")[0]\n\n# Extraemos las componentes del flujo en un arreglo 3D para graficación\nqx, qy, qz = flopy.utils.postprocessing.get_specific_discharge(spdis, o_gwf)\n\n# Calculamos la norma de la descarga específica\nn_q = np.sqrt(np.square(qx[0]) + np.square(qy[0]))\n\nEn este momento tenemos los siguientes arreglos: * head, carga hidráulica. * spdis, descarga específica en un arreglo de tipo recarray con 6 columnas. * qx, qy, qz, componentes de la descarga específica. * n_q, norma del vector de descarga específica para graficación.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MODFLOW 6: simulación de flujo v 1.0</span>"
    ]
  },
  {
    "objectID": "03_MF6_GWF_v1.html#paso-6.-visualización-de-los-resultados.",
    "href": "03_MF6_GWF_v1.html#paso-6.-visualización-de-los-resultados.",
    "title": "4  MODFLOW 6: simulación de flujo v 1.0",
    "section": "6.7 Paso 6. Visualización de los resultados.",
    "text": "6.7 Paso 6. Visualización de los resultados.\nSe visualiza los siguiente: * Permeabilidad (\\(k\\), k_data). * Carga hidráulica (\\(h\\), head). * Descarga específica (\\(q\\), (qx, qy))\n\n# --- Parámetros para las gráficas\ngrid = o_gwf.modelgrid\nx, y, z = grid.xyzcellcenters\nxticks = np.linspace(grid.extent[0], grid.extent[1], 7)\nyticks = np.linspace(grid.extent[2], grid.extent[3], 5)\nxlabels = [f'{x:1.1f}' for x in xticks]\nylabels = [f'{y:1.1f}' for y in yticks]\nkvmin = 1.0 #np.nanmin(k_data)\nkvmax = 0.0 #np.nanmax(k_data)\nhvmin = np.nanmin(head)\nhvmax = np.nanmax(head)\nqvmin = 0.00 #np.nanmin(n_q)\nqvmax = 0.35 #np.nanmax(n_q)\n\n\n# --- Definición de la figura ---\n\n# Se harán tres gráficas en una sola figura.\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize =(10,10))\n\n#--- Gráfica 1. ---\n# Mapa visual del modelo. En este caso el modelo es 'o_gwf'. \nkview = flopy.plot.PlotMapView(model = o_gwf, ax = ax1)\n\n# Visualización de la malla, con una transparencia.\nkview.plot_grid(linewidths = 0.5, alpha = 0.5)\n\n# Visualización de la permeabilidad hidráulica usando un mapa de color.\nk_ac = kview.plot_array(k_data, cmap = \"gist_heat\", vmin = kvmin, vmax = kvmax)\n\n# Barra de color para la permeabilidad hidráulica.\nk_cb = plt.colorbar(k_ac, ax = ax1, label = \"$k$\", \n                    ticks = [0.0, 0.25, 0.50, 0.75, 1.0],\n                    cax = xmf6.vis.cax(ax1, k_ac))\nk_cb.ax.tick_params(labelsize=8)\n\n# Personalización de la gráfica.\nax1.set_title(\"Permeabilidad hidráulica $k$\", fontsize=10)\nax1.set_ylabel(\"$y$ (m)\", fontsize = 8)\nax1.set_xticks(ticks = xticks, labels = xlabels, fontsize = 8)\nax1.set_yticks(ticks = yticks, labels = ylabels, fontsize = 8)\nax1.set_aspect('equal')\n\n### Gráfica 2.\n\n# Mapa visual del modelo. En este caso el modelo es 'o_gwf'. \nhview = flopy.plot.PlotMapView(model = o_gwf, ax = ax2)\n\n# Visualización de la carga hidráulica usando un mapa de color.\nh_ac = hview.plot_array(head, cmap = \"YlGnBu\", vmin = hvmin, vmax = hvmax, alpha = 0.75)\n\n# Visualización de la carga hidráulica usando contornos.\nhview.contour_array(head, levels = 30, cmap = \"bone\", linewidths = 1.0)\n\n# Visualización de los vectores de la descarga específica.\nax2.quiver(x, y, qx[0], qy[0], scale = 3, \n           color = 'k', linewidth = 0.95, pivot = 'middle')\n\n# Barra de color para la carga hidráulica.\nh_cb = plt.colorbar(h_ac, ax = ax2, label = \"$h$ (m)\", \n                    cax = xmf6.vis.cax(ax2, h_ac))\nh_cb.ax.tick_params(labelsize=8)\n\n# Personalización de la gráfica.\nax2.set_title(\"Carga hidráulica $h$\", fontsize=10)\nax2.set_ylabel(\"$y$ (m)\", fontsize = 8)\nax2.set_xticks(ticks = xticks, labels = xlabels, fontsize = 8)\nax2.set_yticks(ticks = yticks, labels = ylabels, fontsize = 8)\nax2.set_aspect('equal')\n\n### Gráfica 3.\n\n# Mapa visual del modelo. En este caso el modelo es 'o_gwf'.\nfview = flopy.plot.PlotMapView(model = o_gwf, ax = ax3)\n\n# Visualización de la descarga hidráulica usando un mapa de color.\nq_ac = fview.plot_array(n_q, cmap = \"winter\", vmin = qvmin, vmax = qvmax, alpha = 0.25)\n\n# Visualización de la carga hidráulica usando contornos.\nfview.contour_array(head, levels = 20, cmap = 'bone', linewidths = 0.75, )\n\n# Visualización de líneas de corriente de la descarga específica.\nax3.streamplot(x, y[::-1][:], qx[0], qy[0][::-1], \n               density = [2, 1.5], linewidth = 0.75, broken_streamlines = True, \n               color = n_q, cmap = \"winter\", \n               arrowstyle = \"-&gt;\", arrowsize = 0.75,  )\n\n# Barra de color para la norma de la descarga hidráulica.\nq_cb = plt.colorbar(q_ac, ax=ax3, label=\"$q$\", \n                    ticks = np.linspace(0.0, 0.35, 7),\n                    format = \"{x:3.2f}\",\n                    cax = xmf6.vis.cax(ax3, q_ac))\nq_cb.ax.tick_params(labelsize=8)\n\n# Personalización de la gráfica.\nax3.set_title(\"Descarga específica $q$\", fontsize=10)\nax3.set_xlabel(\"$x$ (m)\", fontsize = 8)\nax3.set_ylabel(\"$y$ (m)\", fontsize = 8)\nax3.set_xticks(ticks = xticks, labels = xlabels, fontsize = 8)\nax3.set_yticks(ticks = yticks, labels = ylabels, fontsize = 8)\nax3.set_aspect('equal')\n\nplt.tight_layout()\nplt.savefig(\"03_MF6.pdf\")\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>MODFLOW 6: simulación de flujo v 1.0</span>"
    ]
  },
  {
    "objectID": "04_MF6_GWF_v2.html",
    "href": "04_MF6_GWF_v2.html",
    "title": "5  sim_ws = sandbox4",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport flopy\nimport os\nimport xmf6\n\n\ninit = {\n    'sim_name' : \"flow\",\n    'exe_name' : \"C:\\\\Users\\\\luiggi\\\\Documents\\\\GitSites\\\\xmf6\\\\mf6\\\\windows\\\\mf6\",\n    'sim_ws' : \"sandbox4\"\n}\n\ntime = {\n    'units': \"DAYS\",\n    'nper' : 1,\n    'perioddata': [(1.0, 1, 1.0)]\n}\n\nims = {}\n\ngwf = { \n    'modelname': init[\"sim_name\"],\n    'model_nam_file': f\"{init[\"sim_name\"]}.nam\",\n    'save_flows': True\n}\n\ndis = {\n    'nlay': 1, \n    'nrow': 20, \n    'ncol': 30,\n    'delr': 0.5, \n    'delc': 0.5, \n    'top' : 0.0, \n    'botm': -1.0 \n}\n\nic = {\n    'strt': 10\n}\n\nchd_data = []\nfor row in range(dis['nrow']):\n    chd_data.append([(0, row, 0), 10.0])       # Condición en la pared izquierda\n    chd_data.append([(0, row, dis['ncol'] - 1), 5.0]) # Condición en la pared derecha\n\nchd = {\n    'stress_period_data': chd_data,     \n}\n\nk_data = np.random.rand(dis['nlay'], dis['nrow'], dis['ncol'])*1.0 \nk_data[:,5:15,10:20] = 0.1\n\nnpf = {\n    'save_specific_discharge': True,\n    'k': k_data, \n}\n\noc = {\n    'budget_filerecord': f\"{init['sim_name']}.bud\",\n    'head_filerecord': f\"{init['sim_name']}.hds\",\n    'saverecord': [(\"HEAD\", \"ALL\"), (\"BUDGET\", \"ALL\")],\n    'printrecord': [(\"HEAD\", \"ALL\")]\n}\n\n\nFunción xmf6.gwf.initialize().\n\nSIM\nTDIS\nIMS\n\nFunción xmf6.gwf.build().\n\nGWF\n\nDIS\nIC\nCHD\nNPF\nWEL\nOC\n\n\n\n\no_sim = xmf6.gwf.initialize(init = init, time = time, ims = ims)\n\n\n\nsim configuration::\n  sim_name = flow\n  exe_name = C:\\Users\\luiggi\\Documents\\GitSites\\xmf6\\mf6\\windows\\mf6\n\n\n\ntime configuration::\n  units = DAYS\n  nper = 1\n  perioddata = [(1.0, 1, 1.0)]\n---\n\n\n\nnumerical solution configuration::\n---\n\n\n\n\no_gwf = xmf6.gwf.build(o_sim,\n                       gwf = gwf, dis = dis, ic = ic, chd = chd, npf = npf, oc = oc)\n\n\n\nnumerical model configuration::\n  modelname = flow\n  model_nam_file = flow.nam\n  save_flows = True\n---\n\n\n\nspatial discretization configuration::\n  nlay = 1\n  nrow = 20\n  ncol = 30\n  delr = 0.5\n  delc = 0.5\n  top = 0.0\n  botm = -1.0\n---\n\n\n\ninitial conditions configuration::\n  strt = 10\n---\n\n\n\nboundary conditions configuration::\n  stress_period_data = [[(0, 0, 0), 10.0], [(0, 0, 29), 5.0], [(0, 1, 0), 10.0], [(0, 1, 29), 5.0], [(0, 2, 0), 10.0], [(0, 2, 29), 5.0], [(0, 3, 0), 10.0], [(0, 3, 29), 5.0], [(0, 4, 0), 10.0], [(0, 4, 29), 5.0], [(0, 5, 0), 10.0], [(0, 5, 29), 5.0], [(0, 6, 0), 10.0], [(0, 6, 29), 5.0], [(0, 7, 0), 10.0], [(0, 7, 29), 5.0], [(0, 8, 0), 10.0], [(0, 8, 29), 5.0], [(0, 9, 0), 10.0], [(0, 9, 29), 5.0], [(0, 10, 0), 10.0], [(0, 10, 29), 5.0], [(0, 11, 0), 10.0], [(0, 11, 29), 5.0], [(0, 12, 0), 10.0], [(0, 12, 29), 5.0], [(0, 13, 0), 10.0], [(0, 13, 29), 5.0], [(0, 14, 0), 10.0], [(0, 14, 29), 5.0], [(0, 15, 0), 10.0], [(0, 15, 29), 5.0], [(0, 16, 0), 10.0], [(0, 16, 29), 5.0], [(0, 17, 0), 10.0], [(0, 17, 29), 5.0], [(0, 18, 0), 10.0], [(0, 18, 29), 5.0], [(0, 19, 0), 10.0], [(0, 19, 29), 5.0]]\n---\n\n\n\nflow properties configuration::\n  save_specific_discharge = True\n  k = [[[0.60954214 0.4165278  0.59880469 0.77742402 0.83425926 0.29178523\n   0.07997176 0.63055316 0.10080799 0.84034342 0.58251966 0.14685616\n   0.71997601 0.19212944 0.16469966 0.24887592 0.73077801 0.90353812\n   0.02421148 0.3209033  0.42660233 0.33009569 0.71149392 0.06640044\n   0.53761123 0.15403321 0.73331497 0.6325598  0.4233338  0.10060297]\n  [0.58172865 0.59489213 0.47720888 0.7186139  0.17088769 0.27663864\n   0.4431125  0.10531354 0.56255331 0.18103481 0.87588637 0.60414895\n   0.07070339 0.61333832 0.58070383 0.24453826 0.84468363 0.31074807\n   0.3366561  0.01063396 0.86642706 0.33885709 0.52127048 0.43854741\n   0.63139824 0.88296731 0.61651247 0.62249954 0.53600603 0.79623583]\n  [0.42651659 0.85189251 0.76862176 0.0192641  0.92486633 0.45859273\n   0.95222947 0.74718305 0.7303584  0.96669004 0.03797059 0.41581452\n   0.55995294 0.29258672 0.50915158 0.67583881 0.36547336 0.06630294\n   0.97127454 0.60900597 0.15396387 0.60133809 0.8868297  0.36459134\n   0.47613916 0.1834512  0.15922238 0.74681327 0.80542287 0.63698214]\n  [0.08493063 0.21007637 0.31864139 0.10171217 0.10084855 0.65461473\n   0.27637435 0.76873855 0.80473152 0.23698279 0.21767036 0.7080493\n   0.49738631 0.09256222 0.74180426 0.85496122 0.29785593 0.30898477\n   0.68138992 0.21398019 0.78980619 0.91025677 0.84595157 0.33737856\n   0.62253958 0.71005846 0.38156734 0.73047296 0.08941825 0.5618577 ]\n  [0.71061168 0.29468957 0.16549578 0.66360553 0.72325996 0.71499216\n   0.08569351 0.37260317 0.131688   0.5795041  0.95926536 0.11343725\n   0.27230613 0.83758215 0.30964065 0.37883134 0.29639367 0.63075808\n   0.81085514 0.49520185 0.97593826 0.14202662 0.67044399 0.92963538\n   0.80701181 0.56924532 0.75538746 0.96009188 0.15138022 0.21820589]\n  [0.92162446 0.11777162 0.66816536 0.91985051 0.93065289 0.24674941\n   0.51027642 0.35290523 0.15075646 0.21425436 0.1        0.1\n   0.1        0.1        0.1        0.1        0.1        0.1\n   0.1        0.1        0.03633807 0.32857986 0.29322688 0.00196099\n   0.52364293 0.26822774 0.37733374 0.61720164 0.79750417 0.63872012]\n  [0.40899421 0.89045582 0.63089737 0.40582278 0.1574124  0.97798622\n   0.25798593 0.92841246 0.77109303 0.66305755 0.1        0.1\n   0.1        0.1        0.1        0.1        0.1        0.1\n   0.1        0.1        0.4260733  0.5711068  0.06047622 0.58723017\n   0.37066854 0.03590139 0.83174182 0.68410482 0.19430228 0.74566653]\n  [0.48909608 0.40143397 0.71766863 0.88823988 0.19841955 0.46523447\n   0.23884811 0.57743066 0.11683424 0.44784673 0.1        0.1\n   0.1        0.1        0.1        0.1        0.1        0.1\n   0.1        0.1        0.11639044 0.74145373 0.14097811 0.88323276\n   0.32756397 0.6785058  0.59312826 0.72339001 0.35930303 0.07056934]\n  [0.47188999 0.67402566 0.0598525  0.72428385 0.88550466 0.3263359\n   0.56709129 0.11379937 0.8986357  0.17379803 0.1        0.1\n   0.1        0.1        0.1        0.1        0.1        0.1\n   0.1        0.1        0.72221205 0.89874218 0.69565134 0.36238807\n   0.11179486 0.78635862 0.57046664 0.58615268 0.59553973 0.94976285]\n  [0.50503726 0.6355614  0.44647873 0.03569859 0.44456797 0.65613192\n   0.01214675 0.41611311 0.76761505 0.66311039 0.1        0.1\n   0.1        0.1        0.1        0.1        0.1        0.1\n   0.1        0.1        0.56194922 0.03204619 0.95461408 0.75246119\n   0.73386853 0.21528988 0.87108699 0.31797345 0.84903037 0.19728488]\n  [0.16191081 0.20698614 0.36144665 0.18948286 0.81532856 0.96762703\n   0.26893315 0.75286238 0.27806896 0.98215767 0.1        0.1\n   0.1        0.1        0.1        0.1        0.1        0.1\n   0.1        0.1        0.09628858 0.46389259 0.57139433 0.05555563\n   0.06641261 0.10354844 0.63821466 0.64589331 0.5987501  0.33380669]\n  [0.21081234 0.46304405 0.94228682 0.57480994 0.99385803 0.87440511\n   0.24412777 0.3378692  0.80118833 0.94706171 0.1        0.1\n   0.1        0.1        0.1        0.1        0.1        0.1\n   0.1        0.1        0.54011187 0.70446813 0.85334526 0.53270045\n   0.91712264 0.97645601 0.9776483  0.94335103 0.55395428 0.49716771]\n  [0.7351477  0.1976568  0.04880156 0.77312046 0.30244749 0.7289515\n   0.96047552 0.17623309 0.86618092 0.51502403 0.1        0.1\n   0.1        0.1        0.1        0.1        0.1        0.1\n   0.1        0.1        0.55417786 0.46583961 0.65164091 0.46724248\n   0.67813855 0.97581013 0.35308116 0.23586903 0.60014789 0.15751739]\n  [0.71182831 0.81341408 0.24928742 0.81940459 0.09119011 0.14351805\n   0.87831421 0.78086573 0.24781307 0.72275756 0.1        0.1\n   0.1        0.1        0.1        0.1        0.1        0.1\n   0.1        0.1        0.14295445 0.17638646 0.27632532 0.40086105\n   0.75169229 0.64590893 0.44500937 0.97433426 0.85282528 0.47198021]\n  [0.97070155 0.79323625 0.0926608  0.33863488 0.65114285 0.05857631\n   0.86041702 0.58136518 0.02877632 0.62039913 0.1        0.1\n   0.1        0.1        0.1        0.1        0.1        0.1\n   0.1        0.1        0.8772467  0.71246371 0.64517283 0.6291897\n   0.5008465  0.10873085 0.64639637 0.23427497 0.80667509 0.60830658]\n  [0.67902921 0.41613792 0.15886561 0.01517551 0.32729675 0.31170932\n   0.45055506 0.7638732  0.90504783 0.27400773 0.04283054 0.42026607\n   0.20658033 0.97060952 0.73686589 0.07027035 0.27332108 0.75062355\n   0.23843715 0.81012994 0.07389765 0.64320421 0.95219903 0.69276063\n   0.72732776 0.86836107 0.96046007 0.90047045 0.5935871  0.18096066]\n  [0.74038223 0.88442429 0.94867736 0.23565713 0.27983582 0.92766227\n   0.23025879 0.29135481 0.00782693 0.89991441 0.52855816 0.3398044\n   0.12428893 0.09020395 0.7062567  0.6790088  0.76948659 0.81606104\n   0.82018279 0.77556398 0.0196206  0.44562157 0.85888991 0.75357674\n   0.73229664 0.04684407 0.99578841 0.62992741 0.44665919 0.64277267]\n  [0.89412357 0.64700497 0.98000352 0.1885739  0.99814334 0.89585734\n   0.85589407 0.15125979 0.84876382 0.12537594 0.2655866  0.62314632\n   0.88980534 0.4433292  0.41013799 0.85601778 0.97011184 0.76082126\n   0.35077519 0.86173279 0.53425341 0.09267336 0.24040696 0.32353725\n   0.3740524  0.94398973 0.63865311 0.53522329 0.98313504 0.33025271]\n  [0.3454997  0.19925824 0.82498561 0.61767584 0.3233694  0.30111378\n   0.88094893 0.37886199 0.25491263 0.12571527 0.89747098 0.60414257\n   0.21775654 0.32055469 0.25358899 0.75421632 0.56402424 0.70097943\n   0.26981733 0.70447768 0.12850656 0.08597061 0.32757756 0.61899271\n   0.85444533 0.00866161 0.62179413 0.54558051 0.64146646 0.72862054]\n  [0.18398859 0.25501667 0.19902577 0.69882713 0.00929394 0.51422457\n   0.59863361 0.27425144 0.62329835 0.57342179 0.7367898  0.9850804\n   0.01306854 0.76514079 0.41054708 0.87316507 0.170627   0.07714944\n   0.3820619  0.96639174 0.33743642 0.29670213 0.40844918 0.86048357\n   0.46868387 0.90048778 0.24200684 0.40585159 0.01574999 0.98852646]]]\n---\n\n\n\noutput configuration::\n  budget_filerecord = flow.bud\n  head_filerecord = flow.hds\n  saverecord = [('HEAD', 'ALL'), ('BUDGET', 'ALL')]\n  printrecord = [('HEAD', 'ALL')]\n---\n\n\n\n\no_sim.write_simulation(silent = True)\n\n\no_sim.run_simulation(silent=False)\n\nFloPy is using the following executable to run the model: ..\\..\\..\\..\\mf6\\windows\\mf6.exe\n                                   MODFLOW 6\n                U.S. GEOLOGICAL SURVEY MODULAR HYDROLOGIC MODEL\n                            VERSION 6.6.1 02/10/2025\n\n   MODFLOW 6 compiled Feb 10 2025 17:37:25 with Intel(R) Fortran Intel(R) 64\n   Compiler Classic for applications running on Intel(R) 64, Version 2021.7.0\n                             Build 20220726_000000\n\nThis software has been approved for release by the U.S. Geological \nSurvey (USGS). Although the software has been subjected to rigorous \nreview, the USGS reserves the right to update the software as needed \npursuant to further analysis and review. No warranty, expressed or \nimplied, is made by the USGS or the U.S. Government as to the \nfunctionality of the software and related material nor shall the \nfact of release constitute any such warranty. Furthermore, the \nsoftware is released on condition that neither the USGS nor the U.S. \nGovernment shall be held liable for any damages resulting from its \nauthorized or unauthorized use. Also refer to the USGS Water \nResources Software User Rights Notice for complete use, copyright, \nand distribution information.\n\n \n MODFLOW runs in SEQUENTIAL mode\n \n Run start date and time (yyyy/mm/dd hh:mm:ss): 2025/05/18 16:35:52\n \n Writing simulation list file: mfsim.lst\n Using Simulation name file: mfsim.nam\n \n    Solving:  Stress period:     1    Time step:     1\n \n Run end date and time (yyyy/mm/dd hh:mm:ss): 2025/05/18 16:35:52\n Elapsed run time:  0.118 Seconds\n \n Normal termination of simulation.\n\n\n(True, [])\n\n\n\n# --- Recuperamos los resultados de la simulación ---\nhead = xmf6.gwf.get_head(o_sim, o_gwf)\nqx, qy, qz, n_q = xmf6.gwf.get_specific_discharge(o_sim, o_gwf)\n\n\n# --- Parámetros para las gráficas ---\ngrid = o_gwf.modelgrid\nx, y, z = grid.xyzcellcenters\nxticks = np.linspace(grid.extent[0], grid.extent[1], 7)\nyticks = np.linspace(grid.extent[2], grid.extent[3], 5)\nxlabels = [f'{x:1.1f}' for x in xticks]\nylabels = [f'{y:1.1f}' for y in yticks]\nkvmin = 1.0 #np.nanmin(k_data)\nkvmax = 0.0 #np.nanmax(k_data)\nhvmin = np.nanmin(head)\nhvmax = np.nanmax(head)\nqvmin = 0.00 #np.nanmin(n_q)\nqvmax = 0.35 #np.nanmax(n_q)\n\n# --- Definición de la figura ---\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize =(10,10))\n\n# --- Gráfica 1. ---\nkview = flopy.plot.PlotMapView(model = o_gwf, ax = ax1)\nkview.plot_grid(linewidths = 0.5, alpha = 0.5)\nk_ac = kview.plot_array(k_data, cmap = \"gist_heat\", vmin = kvmin, vmax = kvmax)\nk_cb = plt.colorbar(k_ac, ax = ax1, label = \"$k$\", \n                    ticks = [0.0, 0.25, 0.50, 0.75, 1.0],\n                    cax = xmf6.vis.cax(ax1, k_ac))\nk_cb.ax.tick_params(labelsize=8)\nax1.set_title(\"Permeabilidad hidráulica $k$\", fontsize=10)\nax1.set_ylabel(\"$y$ (m)\", fontsize = 8)\nax1.set_xticks(ticks = xticks, labels = xlabels, fontsize = 8)\nax1.set_yticks(ticks = yticks, labels = ylabels, fontsize = 8)\nax1.set_aspect('equal')\n\n# --- Gráfica 2. ---\nhview = flopy.plot.PlotMapView(model = o_gwf, ax = ax2)\nh_ac = hview.plot_array(head, cmap = \"YlGnBu\", vmin = hvmin, vmax = hvmax, alpha = 0.75)\nhview.contour_array(head, levels = 30, cmap = \"bone\", linewidths = 1.0)\nax2.quiver(x, y, qx[0], qy[0], scale = 3, \n           color = 'k', linewidth = 0.95, pivot = 'middle')\nh_cb = plt.colorbar(h_ac, ax = ax2, label = \"$h$ (m)\", \n                    cax = xmf6.vis.cax(ax2, h_ac))\nh_cb.ax.tick_params(labelsize=8)\nax2.set_title(\"Carga hidráulica $h$\", fontsize=10)\nax2.set_ylabel(\"$y$ (m)\", fontsize = 8)\nax2.set_xticks(ticks = xticks, labels = xlabels, fontsize = 8)\nax2.set_yticks(ticks = yticks, labels = ylabels, fontsize = 8)\nax2.set_aspect('equal')\n\n# --- Gráfica 3. ---\nfview = flopy.plot.PlotMapView(model = o_gwf, ax = ax3)\nq_ac = fview.plot_array(n_q, cmap = \"winter\", vmin = qvmin, vmax = qvmax, alpha = 0.25)\nfview.contour_array(head, levels = 20, cmap = 'bone', linewidths = 0.75, )\nax3.streamplot(x, y[::-1][:], qx[0], qy[0][::-1], \n               density = [2, 1.5], linewidth = 0.75, broken_streamlines = True, \n               color = n_q, cmap = \"winter\", \n               arrowstyle = \"-&gt;\", arrowsize = 0.75,  )\nq_cb = plt.colorbar(q_ac, ax=ax3, label=\"$q$\", \n                    ticks = np.linspace(0.0, 0.35, 7),\n                    format = \"{x:3.2f}\",\n                    cax = xmf6.vis.cax(ax3, q_ac))\nq_cb.ax.tick_params(labelsize=8)\nax3.set_title(\"Descarga específica $q$\", fontsize=10)\nax3.set_xlabel(\"$x$ (m)\", fontsize = 8)\nax3.set_ylabel(\"$y$ (m)\", fontsize = 8)\nax3.set_xticks(ticks = xticks, labels = xlabels, fontsize = 8)\nax3.set_yticks(ticks = yticks, labels = ylabels, fontsize = 8)\nax3.set_aspect('equal')\n\nplt.tight_layout()\nplt.savefig(\"04_MF6.pdf\")\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>04_MF6_GWF_v2.html</span>"
    ]
  },
  {
    "objectID": "05_MF6_GWF_wells.html",
    "href": "05_MF6_GWF_wells.html",
    "title": "6  — Recuperamos los resultados de la simulación —",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport flopy\nimport os\nimport xmf6\n\n\ninit = {\n    'sim_name' : \"flow\",\n    'exe_name' : \"C:\\\\Users\\\\luiggi\\\\Documents\\\\GitSites\\\\xmf6\\\\mf6\\\\windows\\\\mf6\",\n    'sim_ws' : \"sandbox5\"\n}\n\ntime = {\n    'units': \"DAYS\",\n    'nper' : 1,\n    'perioddata': [(1.0, 1, 1.0)]\n}\n\nims = {}\n\ngwf = { \n    'modelname': init[\"sim_name\"],\n    'model_nam_file': f\"{init[\"sim_name\"]}.nam\",\n    'save_flows': True\n}\n\ndis = {\n    'nlay': 1, \n    'nrow': 20, \n    'ncol': 30,\n    'delr': 0.5, \n    'delc': 0.5, \n    'top' : 0.0, \n    'botm': -1.0 \n}\n\nic = {\n    'strt': 10\n}\n\nchd_data = []\nfor row in range(dis['nrow']):\n    chd_data.append([(0, row, 0), 10.0])       # Condición en la pared izquierda\n    chd_data.append([(0, row, dis['ncol'] - 1), 5.0]) # Condición en la pared derecha\n\nchd = {\n    'stress_period_data': chd_data,     \n}\n\nk_data = np.random.rand(dis['nlay'], dis['nrow'], dis['ncol'])*1.0 \nk_data[:, dis['nrow']//6 : dis['nrow']*5//6, dis['ncol']//3 : dis['ncol']*2//3] = 0.1\n\nnpf = {\n    'save_specific_discharge': True,\n    'k': k_data, \n}\n\nwell_data = [((0, dis['nrow']//2, dis['ncol']*2//3), -1.0)]\n\nwell = {\n    'stress_period_data': well_data,\n    'pname': \"WEL-1\",\n    'save_flows': True\n}\n\noc = {\n    'budget_filerecord': f\"{init['sim_name']}.bud\",\n    'head_filerecord': f\"{init['sim_name']}.hds\",\n    'saverecord': [(\"HEAD\", \"ALL\"), (\"BUDGET\", \"ALL\")],\n    'printrecord': [(\"HEAD\", \"ALL\")]\n}\n\no_sim = xmf6.gwf.initialize(silent = True, init = init, time = time, ims = ims)\no_gwf = xmf6.gwf.build(o_sim, silent = True,\n                       gwf = gwf, dis = dis, ic = ic, chd = chd, npf = npf, oc = oc, well = well)\n\no_sim.write_simulation(silent = True)\no_sim.run_simulation(silent = True)\n\n(True, [])\n\n\n\nhead = xmf6.gwf.get_head(o_sim, o_gwf)\nqx, qy, qz, n_q = xmf6.gwf.get_specific_discharge(o_sim, o_gwf)\n\n# --- Parámetros para las gráficas ---\ngrid = o_gwf.modelgrid\nx, y, z = grid.xyzcellcenters\nxticks = np.linspace(grid.extent[0], grid.extent[1], 7)\nyticks = np.linspace(grid.extent[2], grid.extent[3], 5)\nxlabels = [f'{x:1.1f}' for x in xticks]\nylabels = [f'{y:1.1f}' for y in yticks]\nkvmin = 1.0 #np.nanmin(k_data)\nkvmax = 0.0 #np.nanmax(k_data)\nhvmin = np.nanmin(head)\nhvmax = np.nanmax(head)\nqvmin = 0.00 #np.nanmin(n_q)\nqvmax = 0.35 #np.nanmax(n_q)\n\n# --- Definición de la figura ---\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize =(10,10))\n\n# --- Gráfica 1. ---\nkview = flopy.plot.PlotMapView(model = o_gwf, ax = ax1)\nkview.plot_grid(linewidths = 0.5, alpha = 0.5)\nk_ac = kview.plot_array(k_data, cmap = \"gist_heat\", vmin = kvmin, vmax = kvmax)\nk_cb = plt.colorbar(k_ac, ax = ax1, label = \"$k$\", \n                    ticks = [0.0, 0.25, 0.50, 0.75, 1.0],\n                    cax = xmf6.vis.cax(ax1, k_ac))\nk_cb.ax.tick_params(labelsize=8)\nax1.set_title(\"Permeabilidad hidráulica $k$\", fontsize=10)\nax1.set_ylabel(\"$y$ (m)\", fontsize = 8)\nax1.set_xticks(ticks = xticks, labels = xlabels, fontsize = 8)\nax1.set_yticks(ticks = yticks, labels = ylabels, fontsize = 8)\nax1.set_aspect('equal')\n\n# --- Gráfica 2. ---\nhview = flopy.plot.PlotMapView(model = o_gwf, ax = ax2)\nh_ac = hview.plot_array(head, cmap = \"YlGnBu\", vmin = hvmin, vmax = hvmax, alpha = 0.75)\nhview.contour_array(head, levels = 30, cmap = \"bone\", linewidths = 1.0)\nax2.quiver(x, y, qx[0], qy[0], scale = 3, \n           color = 'k', linewidth = 0.95, pivot = 'middle')\nh_cb = plt.colorbar(h_ac, ax = ax2, label = \"$h$ (m)\", \n                    cax = xmf6.vis.cax(ax2, h_ac))\nh_cb.ax.tick_params(labelsize=8)\nax2.set_title(\"Carga hidráulica $h$\", fontsize=10)\nax2.set_ylabel(\"$y$ (m)\", fontsize = 8)\nax2.set_xticks(ticks = xticks, labels = xlabels, fontsize = 8)\nax2.set_yticks(ticks = yticks, labels = ylabels, fontsize = 8)\nax2.set_aspect('equal')\n\n# --- Gráfica 3. ---\nfview = flopy.plot.PlotMapView(model = o_gwf, ax = ax3)\nq_ac = fview.plot_array(n_q, cmap = \"winter\", vmin = qvmin, vmax = qvmax, alpha = 0.25)\nfview.contour_array(head, levels = 20, cmap = 'bone', linewidths = 0.75, )\nax3.streamplot(x, y[::-1][:], qx[0], qy[0][::-1], \n               density = [2, 1.5], linewidth = 0.75, broken_streamlines = True, \n               color = n_q, cmap = \"winter\", \n               arrowstyle = \"-&gt;\", arrowsize = 0.75,  )\nq_cb = plt.colorbar(q_ac, ax=ax3, label=\"$q$\", \n                    ticks = np.linspace(0.0, 0.35, 7),\n                    format = \"{x:3.2f}\",\n                    cax = xmf6.vis.cax(ax3, q_ac))\nq_cb.ax.tick_params(labelsize=8)\nax3.set_title(\"Descarga específica $q$\", fontsize=10)\nax3.set_xlabel(\"$x$ (m)\", fontsize = 8)\nax3.set_ylabel(\"$y$ (m)\", fontsize = 8)\nax3.set_xticks(ticks = xticks, labels = xlabels, fontsize = 8)\nax3.set_yticks(ticks = yticks, labels = ylabels, fontsize = 8)\nax3.set_aspect('equal')\n\nplt.tight_layout()\nplt.savefig(\"05_MF6.pdf\")\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>05_MF6_GWF_wells.html</span>"
    ]
  }
]